{"meta":{"title":"Mryan2005's Blog","subtitle":"","description":"All Things in it","author":"Mryan2005","url":"https://www.mryan2005.top","root":"/"},"pages":[{"title":"关于作者","date":"2024-05-12T09:47:39.000Z","updated":"2024-05-18T11:41:42.825Z","comments":true,"path":"about/index.html","permalink":"https://www.mryan2005.top/about/index.html","excerpt":"","text":"倘若用一句话形容，那就是一个追求自由，又害怕伤害到别人，心比天高，却又经常被拉回现实，总是在矛盾中挣扎的人。"},{"title":"分类","date":"2024-05-11T18:57:25.000Z","updated":"2024-05-18T11:41:42.825Z","comments":true,"path":"categories/index.html","permalink":"https://www.mryan2005.top/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2024-05-11T19:05:08.000Z","updated":"2024-05-18T11:41:42.825Z","comments":true,"path":"friends/index.html","permalink":"https://www.mryan2005.top/friends/index.html","excerpt":"","text":"我的瞎写的“书籍”（尚未公开） 书名 简介 《数据结构与算法大全》 一本基于之前写数据结构算法的人所写的数据结构与算法的书籍之上书写的书。 《C++ Language》 一本基于前人的书籍所写的C++语言的书籍。 《C Language》 一本基于前人的书籍所写的C语言的书籍。 我好友的网站 网站名 简介 AkiACG论坛 暂无介绍 AkiACG总站 暂无介绍"},{"title":"标签","date":"2024-05-11T18:57:30.000Z","updated":"2024-05-18T11:41:42.829Z","comments":true,"path":"tags/index.html","permalink":"https://www.mryan2005.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"简谐运动的一些参数","slug":"jianxieyundong-zhenfu-zhouqi-pinglv-xiangwei","date":"2024-05-18T16:32:54.000Z","updated":"2024-05-18T11:41:59.049Z","comments":true,"path":"posts/ebca20c7.html","permalink":"https://www.mryan2005.top/posts/ebca20c7.html","excerpt":"","text":"振幅 A 获取振幅的办法 可以通过图像的最大值或最小值看出，A=∣xmax∣=∣xmin∣A = |x_{max}| = |x_{min}|A=∣xmax​∣=∣xmin​∣。 可以通过初始位移和初始速度求出，A=x02+v02ω2A = \\sqrt{x_0^2+\\frac{v_0^2}{ω^2}}A=x02​+ω2v02​​​。 振幅由初始条件决定，即初始位移和初始速度。 周期与频率（TTT和fff） T=2πω=2πmkν=1T=ω2πω=2πνT = \\frac{2π}{\\omega} = 2π\\sqrt{\\frac{m}{k}}\\\\ \\nu = \\frac{1}{T} = \\frac{\\omega}{2\\pi} \\\\ \\omega = 2\\pi \\nu T=ω2π​=2πkm​​ν=T1​=2πω​ω=2πν 周期和频率是由振动系统的特性决定的。 相位 φ 初相位 初相位决定了物体在t=0t=0t=0时的位置和速度。 获取初相位的办法 可以通过初始位移和初始速度求出，tanφ=−v0ωx0tanφ = -\\frac{v_0}{ωx_0}tanφ=−ωx0​v0​​。 由 x=Acos⁡(ωt+φ)x = A\\cos(ωt+φ)x=Acos(ωt+φ)求取。 由 v=−ωAsin⁡(ωt+φ)v = - \\omega A\\sin(ωt+φ)v=−ωAsin(ωt+φ)求取。 由 ω∗t+φ=θ\\omega*t+φ = \\thetaω∗t+φ=θ 求取。","categories":[{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"简谐运动","slug":"物理/简谐运动","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8/"}],"tags":[]},{"title":"我为什么要创建我的博客","slug":"the_reason_why_I_create_my_blog","date":"2024-05-18T11:41:42.825Z","updated":"2024-05-18T11:41:59.053Z","comments":true,"path":"posts/960aa022.html","permalink":"https://www.mryan2005.top/posts/960aa022.html","excerpt":"","text":"其实，我们都知道计算机界的大佬都是有一个属于自己的博客，并且他们的博客都是自己搭建的。这是因为他们知道，一个人的知识是有限的，而一个团队的知识是无限的。所以，他们会把自己的知识分享出来，让更多的人来帮助他们完善自己的知识体系。 我的梦想就是成为一个计算机界的大佬，所以我也要创建一个自己的博客，来记录自己的学习历程，分享自己的知识。 这让我想起了我在我的高中的数学老师的QQ说说的下面的对于“冒险的梦想”的回复： 我想成为想要我的计算机的学识与Linus Torvalds相当的人。 我想，这就是我为什么要创建我的博客的原因吧。 我会在这里发表我对计算机的知识的整理，其实，也不只是计算机的知识，我还会发表我对于其他领域的知识的整理。希望我的博客能够帮助到你。 最后，伴随着这首歌，我大喊着“向顶峰奔去”。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://www.mryan2005.top/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://www.mryan2005.top/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"回文数","slug":"LeetCode-huiwenshu","date":"2024-05-18T11:19:15.000Z","updated":"2024-05-18T11:41:59.041Z","comments":true,"path":"posts/df58b0a0.html","permalink":"https://www.mryan2005.top/posts/df58b0a0.html","excerpt":"","text":"Problem: 9. 回文数 思路 先拆分，后对比 解题方法 有思路可知。 复杂度 时间复杂度: O(log2n)O(log_2n)O(log2​n) 空间复杂度: O(1) Code 123456789101112bool isPalindrome(int x) &#123; if(x &lt; 0) return false; int divided[40], ListSize; int *p = divided; while(x &gt; 0) &#123; *(p++) = x % 10; x /= 10; &#125; ListSize = p - divided; for(int head = 0, tail = ListSize-1; head &lt; tail; head++, tail--) if(divided[head] != divided[tail]) return false; return true;&#125; 一些碎碎念 有时候，我，Mryan2005，有一种感觉，就是上了大学，但还是逃不过各个学科的考试，基本上只要有一个学科考试，你就得抽出至少一天的时间去准备，这就导致了我很少有时间刷题，但是我还是会坚持下去吧，毕竟，刷题只是为了有一种收剑入鞘的感觉。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mryan2005.top/categories/LeetCode/"},{"name":"简单题","slug":"LeetCode/简单题","permalink":"https://www.mryan2005.top/categories/LeetCode/%E7%AE%80%E5%8D%95%E9%A2%98/"}],"tags":[{"name":"对数字的处理","slug":"对数字的处理","permalink":"https://www.mryan2005.top/tags/%E5%AF%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%A4%84%E7%90%86/"}]},{"title":"2024-05-18更新日志","slug":"updata1","date":"2024-05-18T08:45:51.000Z","updated":"2024-05-18T11:41:59.053Z","comments":true,"path":"posts/b5f574ac.html","permalink":"https://www.mryan2005.top/posts/b5f574ac.html","excerpt":"","text":"目前将会放弃Github page，选择使用Cloudflare page，因为Github page的访问速度实在是太慢了，而且还经常被墙，所以我决定放弃Github page，转而使用Cloudflare page，这样就可以让大家更快的访问我的博客了。","categories":[{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/categories/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/tags/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"}]},{"title":"顺序表","slug":"ds-sqList","date":"2024-05-17T12:22:25.000Z","updated":"2024-05-18T11:41:59.049Z","comments":true,"path":"posts/f35acf61.html","permalink":"https://www.mryan2005.top/posts/f35acf61.html","excerpt":"","text":"别称 线性表的顺序表示、顺序存储结构、顺序映像、随机存取结构的储存结构 作用 利用数组的连续存储空间顺序存放线性表的各个元素 a[n-1]是a[n]的直接前趋，a[n+1]是a[n]的直接后继。 结构体代码 第一种写法 1234typedef struct sqList &#123; ElementType Data[MAXSIZE]; int Last;&#125; sqList; Python 1234class LNode: def __init__(self): self.Data = [] self.last = -1 第二种写法 1234typedef struct sqList &#123; ElementType Data[MAXSIZE]; int length;&#125; sqList; Python 1234class LNode: def __init__(self): self.Data = [] self.length = 0 第三种写法 1234typedef struct sqlList &#123; ElementType *Data; int length;&#125; sqList; Python 1234567891011121314151617class LNode: def __init__(self): self.Data = None self.length = 0···## 初始化### 通过输入来实现的初始化```cint initList(sqList *List, int n) &#123; if(MAXSIZE &lt; n) return 1; ElementType *p = List-&gt;Data; for(int i = 0; i &lt; n; i++, List-&gt;length = i) scanf(&quot;%d&quot;, p++); return 0;&#125; Python 123456789101112131415161718192021def initList(List: LNode, n): for i in range(0,n): List.Data.append(int(input())) List.length += 1···### 通过读取文件实现的初始化```cint initList(sqList *List, int n, FILE *fp) &#123; if(MAXSIZE &lt; n || fp == NULL) return 1; ElementType *p = List-&gt;Data; for(int i = 0; i &lt; n; i++, List-&gt;length = i) &#123; if(sizeof(ElementType) == 4) *(p++) = fgetc(fp) - &#x27;0&#x27;; else if(sizeof(ElementType) == 1) *(p++) = fgetc(fp); if( feof(fp) ) &#123; break ; &#125; &#125; return 0;&#125; 增加 行尾增加 C 1234567int insertNodeFromEnd(sqList *List, int n) &#123; if(MAXSIZE &lt; List-&gt;length+n) return 1; ElementType *p = List-&gt;Data + List-&gt;length; for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, p++); List-&gt;length = n + List-&gt;length; return 0;&#125; Python 12345678910111213141516171819202122def insertNodeFromEnd(List, n): for i in range(1, n+1): List.Data.append(input()) List.length += 1### 行首增加主要原理就是在添加一个Node时，先将原有的向后移一个，再添加。#### C```cint insertNodeFromHead(sqList *List, int n) &#123; if(MAXSIZE &lt; List-&gt;length+n) return 1; ElementType *p = List-&gt;Data; for(int i = 0; i &lt; n; i++) &#123; for(ElementType *q = List-&gt;Data+List-&gt;length; q != p; q--) *q = *(q-1); scanf(&quot;%d&quot;, p); List-&gt;length++; &#125; return 0;&#125; Python 1234def insertNodeFromHead(List, n): for i in range(0, n): List.Data.insert(0, input()) List.length += 1 中间插入 C 12345678910111213int insertNodeFromMiddle(sqList *List, int insertPostion, int n) &#123; if(MAXSIZE &lt; insertPostion+n || MAXSIZE &lt; insertPostion || List-&gt;length &lt; insertPostion) &#123; printf(&quot;insertPostion &gt; List-&gt;length&quot;); return 1; &#125; ElementType *p = List-&gt;Data + insertPostion; for(int i = 0; i &lt; n; i++) &#123; for(ElementType *q = List-&gt;Data+List-&gt;length; q != p; q--) *q = *(q-1); scanf(&quot;%d&quot;, p); List-&gt;length++; &#125; return 0;&#125; Python 1234def insertNodeFromMiddle(List, insertPostion, n): for i in range(0, n): List.Data.insert(insertPostion, input()) List.length += 1 有序插入 原理：从后往前找——&gt;比它小的数的后面 C 1234567891011121314int insertANode(List va, ElementType a) &#123; if(va-&gt;length &gt; MaxSize) &#123; printf(&quot;序列已满&quot;); return 1; &#125; ElementType *p = va-&gt;data + va-&gt;length-1; while(p != va-&gt;data &amp;&amp; a &lt;= *p) &#123; *(p+1) = *p; p--; &#125; *(p+1) = a; va-&gt;length++; return 0;&#125; 删除 通过序号删除 原理：从后往前找——&gt;比它小的数的后面 C 123int removeNodeThroughPosition(List *L, int position) &#123; &#125; 通过匹配结果删除 原理： C 1234567891011121314int removeNodeThroughContent(List *L, ElementType data) &#123; node *p = *L, *q; int positionCurrent = 0; while(p &amp;&amp; p-&gt;next) &#123; p = p-&gt;next; if(p-&gt;data == data) &#123; q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); return 0; &#125; &#125; return 1;&#125; 从i开始删除k个 原理： C 1234567int deleteNodeFromItoK(sqList *List, int i, int k) &#123; if(i &gt; List-&gt;length || i+k-1 &gt; List-&gt;length) return 1; int *p = List-&gt;Data+(i-1); for(int *q = List-&gt;Data+i+k-1; q != List-&gt;Data+List-&gt;length; q++, p++) *p = *q; List-&gt;length -= k; return 0;&#125; 全部删除 C 123int deleteAllNodes(sqList *List) &#123; List-&gt;length = 0;&#125; python 12def deleteAllNodes(List): List.length = 0; 修改 通过序号修改 C 123456789int changeValue(sqList *List, int insertPostion, ElementType value) &#123; if(insertPostion &gt; List-&gt;length) &#123; printf(&quot;insertPostion &gt; List-&gt;length&quot;); return 1; &#125; ElementType *p = List-&gt;Data+(insertPostion-1); *p = value; return 0;&#125; python 123456def changeValue(List, insertPostion, value): if insertPostion &gt; List.length: print(&quot;插入位置超过表长&quot;) return 1 List[insertPostion-1] = value return 0 通过匹配结果修改 C 12345678int changeValue(sqList *List, ElementType value1, ElementType value) &#123; for(int i = 0; i &lt; List-&gt;length; i++) if(*(List-&gt;Data+i) == value1) &#123; *(List-&gt;Data+i) = value; return 0; &#125; printf(&quot;not find&quot;); return 1;&#125; python 123456def changeValue(List, value1, value2): try: List.Data[List.Data.index(value1)] = value2 except ValueError: print(&quot;找不到该值&quot;) return 1 返回信息 返回长度 C 123int getListLength(sqList List) &#123; return List.length;&#125; python 12def getListLength(List): return List.length 返回某一元素的位置 C 12345int getThePositionOfNode(sqList List, int value) &#123; ElementType *p = List.Data; for(int i = 0; i &lt; List-&gt;length; i++) if(p[i] == value) return i+1; return -1&#125; Python 123456def getThePositionOfNode(List, int value): try: return List.Data.index(value)+1 except ValueError: print(&quot;找不到该值&quot;) return 1 返回某一位置元素的信息 C 1234567int getTheContactOfNode(sqList List, int postion) &#123; ElementType *p = List.Data; if(postion &gt; List.length) &#123; return p[postion-1]; &#125; return NULL;&#125; Python 1234def getTheContactOfNode(List, postion): if postion &gt; List.length: return False return List.Data[postion-1] 是否是空表 C 12345#define OK 1#define NO 0int isEmpty(sqList List) &#123; if(List.length) return OK; else return NO; Python 12345def isEmpty(List): if len(List): return 1 else: return 0 获得最大长度 C 123int getMaxSize() &#123; return MAXSIZE;&#125; 对内部数据进行操作 排序 逆置 C 12345678void f(sqList *L) &#123; ElementType *p = L-&gt;Data, temp; for(ElementType *q = L-&gt;Data + L-&gt;length-1; q &gt; p; q--, p++) &#123; temp = *q; *q = *p; *p = temp; &#125;&#125; 参考资料 数据结构（C语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"线性表","slug":"线性表","permalink":"https://www.mryan2005.top/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"矩阵的秩","slug":"juzhendezhi","date":"2024-05-16T11:29:20.000Z","updated":"2024-05-18T11:41:59.049Z","comments":true,"path":"posts/50ea32d2.html","permalink":"https://www.mryan2005.top/posts/50ea32d2.html","excerpt":"","text":"定义 k阶子式 在m✖️n的矩阵A当中，任取k行k列（1≤k≤m，1≤k≤n），位于k2k^2k2个元素。 m✖️n矩阵A的k阶子式共有Cmk⋅CnkC^k_m·C^k_nCmk​⋅Cnk​个。 设A为m✖️n矩阵，当A=Ｏ时，它的任何子式都为零；当A≠Ｏ时，它至少有一个r阶子式不为零。 秩 设Ａ为m✖️n矩阵，如果存在Ａ的r阶子式不为零，而任何的r+1阶子式皆为零，则称数r为矩阵A的秩，记作r(A)或R(A)。 零矩阵的秩等于零。 除了计算矩阵，还可以通过变换矩阵（使其出现都为0的行），直到矩阵不能在变换了。那么有多少行上的元素不为0，那r就等于多少。 性质 若矩阵A中有某个s阶子式不为0，则r(A)≥s； 若A中所有的t阶子式全为0，则r(A)&lt;t； 若A为m✖️n矩阵，则0≤r(A)≤min{m,n}； r(A)=r(ATA^TAT)。 当r(A)=min{m,n}时，为满阶矩阵，否则为降阶矩阵。 矩阵的秩的计算 当A经过一次初等变换变成B时，r(A)=r(B)； 何为初等变换？ 交换两行； 一行上的数乘以一个非零常数； 把一行的数乘以一个非零常数加到另一行上。 由此，当矩阵变成行阶梯形矩阵时，矩阵的秩就是矩阵的非零行的行数。","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"矩阵","slug":"线性代数/矩阵","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/"}],"tags":[{"name":"矩阵","slug":"矩阵","permalink":"https://www.mryan2005.top/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"动态分配","slug":"ds-DynamicAllocation","date":"2024-05-16T10:42:21.000Z","updated":"2024-05-18T11:41:59.045Z","comments":true,"path":"posts/ccb7e96d.html","permalink":"https://www.mryan2005.top/posts/ccb7e96d.html","excerpt":"","text":"前情提要 在之前的C语言的学习当中，我们提到了malloc和free，这两个函数是用来动态分配内存的。 看好。 动态分配的代码是这样写的。 12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int *a = (int*)malloc(sizeof(int)*n); free(a);&#125; 结构体结构 12345typedef struct &#123; ElemType *data; int length; int listSize;&#125; DA; 我来解释一下，这个结构体声明。 length是你实际存了多少的东西，listSize是你目前表的最大长度。 动态分配的使用 其实，无非就是创、增、删、改、读、销。 创建一个动态分配 其实，就是借空间，然后初始化。当然，有的是选择将借空间和初始化这两个操作分开来做。 1234#define INITIALSIZE 100DA da;da.listSize = INITALSIZE;da.length = 0; 初始化动态分配 算了，我还是写出来吧。 1234void initDynamicAllocation(DA *da) &#123; da-&gt;data = (ElemType*)malloc(sizeof(ElemType)*INITIALSIZE); /* initial process */&#125; 添加内容 12345void addContent(DA *da, ElemType content) &#123; ElemType *p = da-&gt;data+length; *p = content; da-&gt;length++;&#125; 参考资料 数据结构（C语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"动态分配","slug":"动态分配","permalink":"https://www.mryan2005.top/tags/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/"}]},{"title":"简谐运动（入门）","slug":"jianxieyundong","date":"2024-05-14T09:10:32.000Z","updated":"2024-05-18T11:41:59.049Z","comments":true,"path":"posts/67c22e3.html","permalink":"https://www.mryan2005.top/posts/67c22e3.html","excerpt":"","text":"弹簧振子 一端固定，一端连接物体，在平衡位置O点反复运动，如下图所示 物理情景：将物块拉到A位置上，然后撤掉拉力，物体发生运动。 当物体到达O点时，物体加速度为0，因为弹力为0； 当物体到达A点的时候，速度减为0。 在这里我们知道，弹力的计算公式是 F=−kxF = -kxF=−kx。 由此，我们可以由加速度公式 a=Fma=\\frac{F}{m}a=mF​ 推出 a=−kxma=-\\frac{kx}{m}a=−mkx​。 由于 ω2=km\\omega^2 = \\frac{k}{m}ω2=mk​，所以，a=−ω2xa = -\\omega^2xa=−ω2x。 而微分方程就是在这基础之上将aaa变成d2xdt2\\frac{d^2x}{dt^2}dt2d2x​。 这里我们要引出一个公式，就是运动方程：x=Acos⁡(wt+ϕ)x = A\\cos(wt+\\phi)x=Acos(wt+ϕ) 然后，我们结合物理学上册的运动描述 v=dxdtv = \\frac{dx}{dt}v=dtdx​，a=dvdta = \\frac{dv}{dt}a=dtdv​，我们可以知道，v=−ωAsin⁡(wt+ϕ)v = - \\omega A\\sin(wt+\\phi)v=−ωAsin(wt+ϕ)，a=ω2Acos⁡(wt+ϕ)a = \\omega^2A\\cos(wt+\\phi)a=ω2Acos(wt+ϕ)","categories":[{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"简谐运动","slug":"物理/简谐运动","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8/"}],"tags":[]},{"title":"线性表入门","slug":"ds-linearList-1","date":"2024-05-12T15:00:51.000Z","updated":"2024-05-18T11:41:59.045Z","comments":true,"path":"posts/371e8e7e.html","permalink":"https://www.mryan2005.top/posts/371e8e7e.html","excerpt":"","text":"定义 线性表（linear list）有以下三个规则： 存在唯一的一个“第一个”数据元素 存在唯一的一个“最后一个”数据元素 除“第一个”和“最后一个”元素均只有一个直接前驱（immediate predecessor）和一个直接后继（immediate successor）。 一些参数 线性表长度为n，也可以直接用xxLen表示 当n=0时，就是空表 a的下表i表示的是a(i)在线性表的位序 一些要说的东西 对于线性表存在两种输入的情况： 不修改内容，只是把内容传入，如List L 譬如，getLength(List L) 可修改内容，也可把内容传入，就传地址（指针），如List *L 譬如，initList(List *L) 但是，在此后要访问这指针的内容要用到L-&gt; 但是，我们要注意的是结构体。 举个例子 这是一个动态分配 12345typedef struct &#123; ElemType *data; int length; int listSize;&#125; DA; 注意，如果我们要修改结构体变量的内容（即data、length、listSize），那就直接传地址，如果我们只是读取，那就传变量即可。 譬如，我们的读取函数 123void readDA(DA da) &#123; for(int i = 0; i &lt; da.length; i++) printf(&quot;%d&quot;, da.data[i]);&#125; 这就是直接传变量本身。 如果们要对该变量本身进行一系列的修改的时候，下面的增加函数代码 12345void addContent(DA *da, ElemType content) &#123; ElemType *p = da-&gt;data+da-&gt;length; *p = content; da-&gt;length++;&#125; 这就是直接传地址的。 参考资料 数据结构（C语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"},{"name":"线性表","slug":"线性表","permalink":"https://www.mryan2005.top/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"算法的基础知识","slug":"ds-algorithm","date":"2024-05-12T10:51:11.000Z","updated":"2024-05-18T11:41:59.045Z","comments":true,"path":"posts/5e7b20a2.html","permalink":"https://www.mryan2005.top/posts/5e7b20a2.html","excerpt":"","text":"算法的五大特性 确定性 有穷性 可行性 输入和输出（可以没有输入，但是得要有输出） 辨析 程序是不是算法？ 答案是False，因为程序可以没有输入。 算法的要求 正确性（correctness） 可读性（readability） 健壮性（robustness） 效率与低储存量需求 算法的书写 我们要把它写成一个函数。 声明行由返回值类型（int、char、double、float、void、long int）、函数名称和形式参数声明区构成 123456returnValueType functionName(type1 value1;type2 value2) &#123; command 1; command 2; …… command n;&#125; 如果没有声明行，那一定要原型声明，如果不进行原型声明，就有可能造成C语言去猜测变量。 如果输入参数与定义的不匹配，那么会发生变量类型转换。 当然如果你把要声明的函数放到main函数的前面或者是放到头文件当中就不会需要声明行了。 总之，要知道，我们要用到函数来表示一个算法。譬如，我们要从顺序表（从零号位开始存数据，里面的数值都大于等于0）中返回指定位置的值： 1234567891011/*#define maxSize 100 typedef struct &#123; elementType data[maxSize]; int length;&#125;;*/elementType initAlist(seqList *L, int i) &#123; if(i &gt; L-&gt;length) return -1; return L-&gt;data[i-1];&#125; 至于顺序表是什么，为什么要特别声明是从0号位开始，我们以后再说。 不过，在这里形式参数声明区代表的是要输入的值的区域，函数名称得表达出算法的用途，实在不行可以随意。 算法的衡量标准 即时间复杂度（time complexity）和空间复杂度（space complexity）。 时间复杂度（time complexity） 又分为事前估计和事后估计 事前估计 语句频度 顺序结构、分支结构、循环结构——运行次数会有变化，取最大的运行次数。 渐进时间复杂度（asymptotic time complexity） T(n) = O(f(n))，渐进时间复杂度。 主要是要找到关键操作（递归和循环），就是嵌套最深的语句，可以是判断、也可以是普通语句。 当存在最好和最坏情况后，用平均复杂度。 例题 1 多重循环 一重循环 事后统计 利用计算机的计时工具，用一组或多组数据去测。缺点是要运行程序，还会依赖于硬件、软件等因素。 空间复杂度（space complexity） 算法本身会占用：输入、输出、指令、常数、变量等。 看看弄出了多少空间被占用。 注意：如果是递归的算法，那就是看层数，不是看节点数，因为递归算法是单线程的弄完一个以后，就会删除掉。 参考资料 详解时间复杂度计算公式(附例题细致讲解过程) 数据结构（C语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"},{"name":"算法","slug":"算法","permalink":"https://www.mryan2005.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"随机事件的概率","slug":"suijishijiandepinglv","date":"2024-05-11T23:59:41.000Z","updated":"2024-05-18T11:41:59.049Z","comments":true,"path":"posts/98650707.html","permalink":"https://www.mryan2005.top/posts/98650707.html","excerpt":"","text":"随机事件的频率 在相同条件下重复进行的n次随机试验中，事件A发生的次数记为rn(A)r_n(A)rn​(A)，称rn(A)r_n(A)rn​(A)为事件A发生的频数，称fn(A)=rn(A)nf_n(A)=\\frac{r_n(A)}{n}fn​(A)=nrn​(A)​为事件A发生的频率。 性质 非负性：0≤fn(A)≤10\\leq f_n(A)\\leq 10≤fn​(A)≤1 规范性：fn(S)=1f_n(S)=1fn​(S)=1 有限可加性：设A1,A2,……，AnA_1, A_2, ……，A_nA1​,A2​,……，An​是两两互不相容事件，fn(A1∪A2∪⋯∪An)=fn(A1)+fn(A2)+⋯+f(An)f_n(A_1∪A_2∪⋯∪A_n) =f_n(A_1)+f_n(A_2)+⋯+f(A_n)fn​(A1​∪A2​∪⋯∪An​)=fn​(A1​)+fn​(A2​)+⋯+f(An​) 随机事件的概率 相同条件下重复进行n次试验，若事件A发生的频率fn(A)f_n(A)fn​(A)随着试验次数n的增大而稳定地在某个常数P(0≤P≤1)P(0\\leq P\\leq1)P(0≤P≤1)附近摆动，则称P为事件A的概率，记为P(A)P(A)P(A)。 投掷硬币的试验中，正面朝上的概率为0.50.50.5。","categories":[{"name":"数学","slug":"数学","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/"},{"name":"概率论与数理统计","slug":"数学/概率论与数理统计","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"数据的基本概念","slug":"ds-data","date":"2024-05-11T23:02:32.000Z","updated":"2024-05-18T11:41:59.045Z","comments":true,"path":"posts/10aa7cbc.html","permalink":"https://www.mryan2005.top/posts/10aa7cbc.html","excerpt":"","text":"数据（data） 能输入到计算机当中的并能被处理的符号的总称。 数据元素（data item） 数据的基本单位，通常是以一个整体去考虑，有若干个数据项组成，又名记录。 在计算机当中，最小的储存单位是位（bit），就是二进制数的一位。将若干个位组合起来连成一个位串表示一个数据元素，通常这个位串为一个元素（element）或结点（node），有时可以看成是数据元素在计算机中的映像。 当数据元素组成各个数据项时，位串应于各个数据项的子串称为数据域（data field） 数据对象（data object） 性质相同的数据元素的集合，是数据的子集。 数据结构（data structure） 存在一种或一种以上的特殊关系的数据元素的集合——Data_Structure = (D,S) D是数据元素的有限集，S是D上关系的有限集 数据结构通常分为4种基本结构： 集合 线性 树 图 数据结构在计算机的表示成为数据的物理结构（physical structure），又称为储存结构（storage structure），同时，这也包括了数据元素的表示和关系的表示。 数据项（data element） 数据的最小单位 数据类型（data type） 用于刻画操作对象的特性：譬如，整型数据可以进行加减乘除，字符型的只能进行加减 两大分类： 原子类型，譬如：C语言中的整型、浮点型、字符型、枚举型 结构类型：若干个数据类型组成（可以是结构的、也可以是非结构的） 抽象数据类型 [ ADT ]（abstract data type） 分为两种类型： 原子类型 结构类型 固定聚合类型，“值”确定的 可变聚合类型，“值”的成分不确定 定义上分为三个部分：数据对象（data object）、数据关系（data relation）、基本操作。 数据的关系描述的是数据元素之间的逻辑关系，由此被称为逻辑关系（logical structure）。 数据关系在计算机的储存方法有两种： 顺序映像 非顺序映像 同时，也有两种储存结构： 顺序储存结构（sequential storage structure） 链式储存结构（linked storage structure） 参考资料 数据结构（C语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"作者有话说","slug":"ds-author-went-to-say","date":"2024-05-11T22:58:51.000Z","updated":"2024-05-18T11:41:59.045Z","comments":true,"path":"posts/506fb8af.html","permalink":"https://www.mryan2005.top/posts/506fb8af.html","excerpt":"","text":"我依稀记得，小时候的我，便与计算机结下了不解之缘。那时的我，对计算机充满了好奇，总是想要探索这个神奇的小盒子里的奥秘。每次坐在电脑前，我都会瞪大眼睛，仔细观察屏幕上的每一个图标，尝试着去理解它们的功能和用途。 随着时间的推移，我逐渐对计算机产生了热爱之情。我开始沉迷于计算机的命令行，那些看似复杂的指令和代码，在我眼中却充满了魅力。我喜欢通过命令行来控制计算机，完成各种任务，那种掌控感让我兴奋不已。我开始研究各种计算机知识，从硬件到软件，从操作系统到编程语言，我都想要了解得更多。 在小学五年级的时候，我第一次接触到了C语言。那时的我，满怀激情地投入到学习中，想要掌握这门强大的编程语言。然而，现实却给我泼了一盆冷水。我发现，我所使用的书籍中充满了错误，这让我感到十分沮丧。最终，我无奈地选择了放弃，转而寻找其他更适合我的编程语言。 初中的时候，我接触到了Python。与C语言相比，Python的语法更加简洁易懂，让我越用越得心应手。我开始用Python编写各种小程序，解决实际问题。我喜欢Python的灵活性和强大性，它让我感受到了编程的乐趣。 在填报高考志愿时，我坚决地选择了计算机专业，不顾家人的阻拦。他们总是以我那高考成绩只够上二本末的堂哥为例子，试图说服我放弃这个选择。然而，我深知自己的兴趣和优势所在，我坚信自己能够在计算机专业中取得好成绩。最终，我成功地进入了大学，开始了我的计算机学习之旅。 在上海的校园里，我遇到了一些同样是学计算机的同学。他们中有些人总是喜欢在我面前炫耀自己的成绩和成就，搞些所谓的“凡尔赛”。然而，我对此却甚为厌恶。我深知，真正的进步和成就不是靠炫耀得来的，而是需要脚踏实地地学习和实践。因此，我选择了超越他们，用自己的努力和成果来证明自己的实力。我坚信，只要我坚持不懈地努力下去，我一定能够在计算机领域取得属于自己的辉煌成就。 在未来的日子里，我将会继续深耕计算机领域，不断提升自己的技能和知识。无论是面对复杂的算法问题，还是应对日新月异的科技变革，我都会保持一颗求知的心，勇于挑战自我，不断超越极限。 或许，我会遇到更多的困难和挑战，但我相信，只要我坚定信念，勇往直前，就一定能够克服一切难关，实现自己的梦想。我期待着在计算机的世界里，书写属于自己的精彩篇章，用智慧和汗水创造出更多的可能。 回首过去，我为自己的选择和坚持感到自豪。展望未来，我充满了信心和期待。我相信，在不久的将来，我将成为一名优秀的计算机专业人才，为社会的进步和发展贡献自己的力量。","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"序言","slug":"dsxuyan","date":"2024-05-11T21:34:37.000Z","updated":"2024-05-18T11:41:59.049Z","comments":true,"path":"posts/3491a993.html","permalink":"https://www.mryan2005.top/posts/3491a993.html","excerpt":"","text":"在浩瀚的计算机科学领域中，数据结构与算法无疑是其中最璀璨夺目的明珠。然而，想要真正掌握这门学科，却并非一撮而就的易事。它需要我们有足够的耐心，去一步步探寻每一个细节；它需要我们有足够的毅力，去克服每一个难关。因此，学习数据结构与算法，更像是一场循序渐进的修行，需要我们在实践中不断积累、反思与提升。 本书《数据结构与算法大全》正是基于这样的理念而诞生。它不仅仅是一本简单的教程，更是一部集大成之作。在编写过程中，我们深入研究了各种数据结构与算法的原理、特性及应用场景，力求将最精华、最实用的内容呈现给读者。同时，我们也参考了大量的专业书籍、学术论文以及实际项目经验，以期为读者提供一个全面、深入的学习平台。 在书中，你将看到各种经典的数据结构，如数组、链表、栈、队列、树和图等，以及与之相关的算法实现和优化方法。我们将从基础概念讲起，逐步深入到高级应用和算法设计技巧，让你能够逐步建立起自己的知识体系和技能体系。 此外，本书还注重理论与实践的结合。我们不仅在理论层面详细讲解了数据结构与算法的基本原理和特性，还通过大量的示例和案例，让读者能够更好地理解其在实际问题中的应用。相信通过本书的学习，你不仅能够掌握数据结构与算法的核心知识，还能够将其应用于实际项目中，提升自己的编程能力和问题解决能力。 最后，我要感谢所有为这本书付出努力的人，也要感谢每一位选择阅读这本书的读者。希望它能够成为你学习数据结构与算法的良师益友，陪伴你走过一段充满挑战与收获的学习旅程。愿你在这个领域中不断前行，创造出更加辉煌的未来。","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"随机事件与概率","slug":"suijishijianyugailv","date":"2024-05-11T21:10:06.000Z","updated":"2024-05-18T11:41:59.053Z","comments":true,"path":"posts/becb01a7.html","permalink":"https://www.mryan2005.top/posts/becb01a7.html","excerpt":"","text":"确定性现象和不确定性现象 确定性现象 如果在一相同条件下的试验中只会有一种结果出现，这种现象称为确定性现象 不确定性现象 如果在一相同条件下的试验中可能出现多种结果，这种现象称为不确定性现象，也称为随机现象。 例子 抛硬币 掷骰子 抽奖 随机试验 特征 可重复 不确定 可观察 样本空间 随机试验E的所有可能结果组成的集合称为E的样本空间，记为S或Ω。样本空间的元素称为样本点，用ω表示。 分类 离散型的样本空间，以散乱的点表示 连续型的样本空间，以线段表示 随机事件 样本空间S的子集称为随机事件，简称事件。 通常以大写字母A、B、C等表示事件。 只有A中的样本点出现时，称事件A发生，否则称事件A不发生。B、C等事件类似。 例子 做如下随机试验：从整数1~9中随机抽取一个数，则样本空间S={1,2,3,4,5,6,7,8,9}S = \\{1,2,3,4,5,6,7,8,9\\}S={1,2,3,4,5,6,7,8,9} 设事件A表示抽到的数不小于5，即A={5,6,7,8,9}A = \\{5,6,7,8,9\\}A={5,6,7,8,9}。 设事件B表示抽到的是偶数，即B={2,4,6,8}B = \\{2,4,6,8\\}B={2,4,6,8}。 A同学随机抽取的数是2，则我们称事件A没有发生，事件B发生。 B同学随机抽取的数是6，则我们称事件A和B都发生。 C同学随机抽取的数是1，则我们称事件A和B都没有发生。 D同学随机抽取的数是9，则我们称事件A发生，事件B没有发生。 必然事件 一定会发生的事件称为必然事件。也就是这一事件包含所有的样本点。 不可能事件 一定不会发生的事件称为不可能事件。也就是这一事件不包含任何样本点，为空集。 包含关系与相等关系 包含关系 如果属于A的样本点必属于B，则称事件B包含事件A，或称事件A被包含于事件B，记为A⊂B，或B⊃A。 事件A 发生必然导致事件B发生。 相等关系 如果A⊂B且B⊂A，则称事件A与事件B相等，记为A=B。 事件A发生等价于事件B发生。 和（并）运算 由属于事件A或属于事件B的样本点组成的新事件称为事件A与事件B的和事件，记为A⋃B或A+B。 事件A发生或事件B发生，即事件A与事件B中至少有一事件发生。 积（交）运算 由属于事件A且属于事件B的样本点组成的新事件称为事件A与事件B的积事件，记为A⋂B或AB。 事件A发生且事件B发生，即事件A与事件B同时发生。 差运算 由属于事件A且不属于事件B的样本点组成的新事件称为事件A与事件B的差事件，记为A-B。 事件A发生且事件B不发生。 对立事件、互不相容（互斥事件）、独立事件 感觉解释这样的东西，只能用人际交往的方式来解释。 对立事件 事件A的对立事件记为A‾\\overline{A}A，即A‾=S−A\\overline{A} = S - AA=S−A。 一句话，我们两没办法处了，“你出现”的事件发生，“我出现”的事件就不发生，反之亦然。（我怎么写也是刚好气头上想出来的，别往心里去） 互不相容事件（互斥事件） 两者之间没有交集，即A⋂B=∅A⋂B = \\emptysetA⋂B=∅。 这像不像你跟一些人的思想，无论怎么谈，都谈不到一块去。 独立事件 A事件的发生不影响B事件的发生，B事件的发生不影响A事件的发生。 符合P(AB)=P(A)P(B)P(AB) = P(A)P(B)P(AB)=P(A)P(B)的事件称为独立事件。 注意：P(A‾B‾)=P(A‾)P(B‾)P(\\overline{A}\\overline{B}) = P(\\overline{A})P(\\overline{B})P(AB)=P(A)P(B)也成立。 事件的运算律 交换律：A⋃B=B⋃AA⋃B = B⋃AA⋃B=B⋃A，AB=BAAB = BAAB=BA 结合律：(A⋃B)⋃C=A⋃(B⋃C)(A⋃B)⋃C = A⋃(B⋃C)(A⋃B)⋃C=A⋃(B⋃C)，(AB)C=A(BC)(AB)C = A(BC)(AB)C=A(BC) 分配律：A(B⋃C)=AB⋃ACA(B⋃C) = AB⋃ACA(B⋃C)=AB⋃AC，A⋃(BC)=(A⋃B)(A⋃C)A⋃(BC) = (A⋃B)(A⋃C)A⋃(BC)=(A⋃B)(A⋃C) 对偶律：A⋃B‾=A‾⋂B‾\\overline{A⋃B} = \\overline{A}⋂\\overline{B}A⋃B​=A⋂B，AB‾=A‾⋃B‾\\overline{AB} = \\overline{A}⋃\\overline{B}AB=A⋃B","categories":[{"name":"数学","slug":"数学","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/"},{"name":"概率论与数理统计","slug":"数学/概率论与数理统计","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"test_all_things","slug":"test-all-things","date":"2024-05-11T20:06:44.000Z","updated":"2024-05-18T11:41:59.053Z","comments":true,"path":"posts/90341f05.html","permalink":"https://www.mryan2005.top/posts/90341f05.html","excerpt":"","text":"mathjax test INLINE EQUATIONS y=mx+by = mx + by=mx+b MULTI-LINE EQUATIONS evidencei=∑jWijxj+bievidence_{i}=\\sum_{j}W_{ij}x_{j}+b_{i} evidencei​=j∑​Wij​xj​+bi​ code test 12def test(): print(&quot;test&quot;)","categories":[{"name":"test example","slug":"test-example","permalink":"https://www.mryan2005.top/categories/test-example/"}],"tags":[{"name":"test","slug":"test","permalink":"https://www.mryan2005.top/tags/test/"}]}],"categories":[{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"简谐运动","slug":"物理/简谐运动","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://www.mryan2005.top/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mryan2005.top/categories/LeetCode/"},{"name":"简单题","slug":"LeetCode/简单题","permalink":"https://www.mryan2005.top/categories/LeetCode/%E7%AE%80%E5%8D%95%E9%A2%98/"},{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/categories/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"},{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"},{"name":"线性代数","slug":"线性代数","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"矩阵","slug":"线性代数/矩阵","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/"},{"name":"数学","slug":"数学","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/"},{"name":"概率论与数理统计","slug":"数学/概率论与数理统计","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"test example","slug":"test-example","permalink":"https://www.mryan2005.top/categories/test-example/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://www.mryan2005.top/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"对数字的处理","slug":"对数字的处理","permalink":"https://www.mryan2005.top/tags/%E5%AF%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%A4%84%E7%90%86/"},{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/tags/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"},{"name":"线性表","slug":"线性表","permalink":"https://www.mryan2005.top/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"矩阵","slug":"矩阵","permalink":"https://www.mryan2005.top/tags/%E7%9F%A9%E9%98%B5/"},{"name":"动态分配","slug":"动态分配","permalink":"https://www.mryan2005.top/tags/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/"},{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"},{"name":"算法","slug":"算法","permalink":"https://www.mryan2005.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"test","slug":"test","permalink":"https://www.mryan2005.top/tags/test/"}]}