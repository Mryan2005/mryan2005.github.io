{"meta":{"title":"Mryan2005's Blog","subtitle":"All Things is in it","description":"","author":"Mryan2005","url":"https://www.mryan2005.top","root":"/"},"pages":[{"title":"关于作者","date":"2024-05-12T09:47:39.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"about/index.html","permalink":"https://www.mryan2005.top/about/index.html","excerpt":"","text":"倘若用一句话形容，那就是一个追求自由，又害怕伤害到别人，心比天高，却又经常被拉回现实，总是在矛盾中挣扎的人。 我的编程经历 我从初中的时候就开始学 Python，不过，对外我是说我学的是 Visual Basic，因为，我高中的时候学的就是 Visual Basic，并且我觉得我的 Python 没有到达精通的水平，所以我不想说我会 Python。后来，在大学，我学的是 C 语言，可能是因为我之前学了 Python 做基础，所以，C 语言不算是很困难，反而是我用得较为平凡的语言，至于 Python，那算是第二多的了。 我写过一些 Python 项目，譬如 EasyGitTool、SSPUBot 等等，这些项目都被开源在了 GitHub 上，欢迎大家去看看。 说到底，我写项目只是想让计算机代码的学习不变得枯燥，并不是单单纯纯的为了写项目而写项目。 热爱的许可证 话说回去，对于开源许可证，我比较倾向于 MPL-2.0，就是传说中的 Mozilla Public License 2.0，我的 Blog 采用的则是 CC-BY-NC-SA 4.0。 热爱的漫画人物 我热爱的漫画人物是灰原，她是一个天才科学家。我很喜欢她。"},{"title":"分类","date":"2024-05-11T18:57:25.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"categories/index.html","permalink":"https://www.mryan2005.top/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2024-05-11T19:05:08.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"friends/index.html","permalink":"https://www.mryan2005.top/friends/index.html","excerpt":"","text":"我好友的网站 AkiACG 论坛 https://forum.akiacg.com/ AkiACG 总站 https://akiacg.com/"},{"title":"标签","date":"2024-05-11T18:57:30.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"tags/index.html","permalink":"https://www.mryan2005.top/tags/index.html","excerpt":"","text":""},{"title":"works","date":"2024-05-25T09:56:01.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"works/index.html","permalink":"https://www.mryan2005.top/works/index.html","excerpt":"","text":"我的瞎写的 “书籍”（尚未公开） 书名 简介 《数据结构与算法大全》 一本基于之前写数据结构算法的人所写的数据结构与算法的书籍之上书写的书。 《C++ Language》 一本基于前人的书籍所写的 C++ 语言的书籍。 《C Language》 一本基于前人的书籍所写的 C 语言的书籍。"}],"posts":[{"title":"2024-06-01 更新日志","slug":"update2","date":"2024-06-01T22:37:03.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/23AEAY0.html","permalink":"https://www.mryan2005.top/posts/23AEAY0.html","excerpt":"添加显示文章摘要功能，即在文章中添加 &lt;!--more--&gt;，在此之前，只有标题和日期，现在，可以显示文章的摘要了。 添加了评论功能。 添加了思维导图功能。","text":"添加显示文章摘要功能，即在文章中添加 &lt;!--more--&gt;，在此之前，只有标题和日期，现在，可以显示文章的摘要了。 添加了评论功能。 添加了思维导图功能。","categories":[{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/categories/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/tags/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"}]},{"title":"Latex 大全","slug":"LatexAll","date":"2024-05-31T23:25:36.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/41713084.html","permalink":"https://www.mryan2005.top/posts/41713084.html","excerpt":"本来我是不想写这份文件的，毕竟，往上面很多，我写只不过是水一次博文，但是，他们写的不算很全面，所以，我决定写一份 Latex 大全，这样，我就可以不用再全网搜索了。","text":"本来我是不想写这份文件的，毕竟，往上面很多，我写只不过是水一次博文，但是，他们写的不算很全面，所以，我决定写一份 Latex 大全，这样，我就可以不用再全网搜索了。 基本运算 符号 代码 表现 加号 $+$ +++ 减号 $-$ −-− 乘号 $*$ ∗*∗ 除号 $/$ /// 等号 $=$ === 不等号 $\\neq$ ≠\\neq= 大于号 $&gt;$ &gt;&gt;&gt; 小于号 $&lt;$ &lt;&lt;&lt; 大于等于号 $\\geq$ ≥\\geq≥ 小于等于号 $\\leq$ ≤\\leq≤ 约等号 $\\approx$ ≈\\approx≈ 等价号 $\\equiv$ ≡\\equiv≡ 点乘 $\\cdot$ ⋅\\cdot⋅ 叉乘 $\\times$ ×\\times× sin 函数 $\\sin$ sin⁡\\sinsin cos 函数 $\\cos$ cos⁡\\coscos tan 函数 $\\tan$ tan⁡\\tantan cot 函数 $\\cot$ cot⁡\\cotcot sec 函数 $\\sec$ sec⁡\\secsec csc 函数 $\\csc$ csc⁡\\csccsc ln 函数 $\\ln$ ln⁡\\lnln log 函数 $\\log$ log⁡\\loglog exp 函数 $\\exp$ exp⁡\\expexp max 函数 $\\max$ max⁡\\maxmax min 函数 $\\min$ min⁡\\minmin lim 函数 $\\lim$ lim⁡\\limlim sup 函数 $\\sup$ sup⁡\\supsup inf 函数 $\\inf$ inf⁡\\infinf arg 函数 $\\arg$ arg⁡\\argarg gcd 函数 $\\gcd$ gcd⁡\\gcdgcd det 函数 $\\det$ det⁡\\detdet Pr 函数 $\\Pr$ Pr⁡\\PrPr 希腊字母 符号 代码 表现 α\\alphaα $\\alpha$ α\\alphaα A\\AlphaA $\\Alpha$ A\\AlphaA β\\betaβ $\\beta$ β\\betaβ B\\BetaB $\\Beta$ B\\BetaB γ\\gammaγ $\\gamma$ γ\\gammaγ Γ\\GammaΓ $\\Gamma$ Γ\\GammaΓ δ\\deltaδ $\\delta$ δ\\deltaδ Δ\\DeltaΔ $\\Delta$ Δ\\DeltaΔ ϵ\\epsilonϵ $\\epsilon$ ϵ\\epsilonϵ E\\EpsilonE $\\Epsilon$ E\\EpsilonE ε\\varepsilonε $\\varepsilon$ ε\\varepsilonε ζ\\zetaζ $\\zeta$ ζ\\zetaζ Z\\ZetaZ $\\Zeta$ Z\\ZetaZ η\\etaη $\\eta$ η\\etaη H\\EtaH $\\Eta$ H\\EtaH θ\\thetaθ $\\theta$ θ\\thetaθ ϑ\\varthetaϑ $\\vartheta$ ϑ\\varthetaϑ ι\\iotaι $\\iota$ ι\\iotaι I\\IotaI $\\Iota$ I\\IotaI κ\\kappaκ $\\kappa$ κ\\kappaκ K\\KappaK $\\Kappa$ K\\KappaK λ\\lambdaλ $\\lambda$ λ\\lambdaλ Λ\\LambdaΛ $\\Lambda$ Λ\\LambdaΛ μ\\muμ $\\mu$ μ\\muμ M\\MuM $\\Mu$ M\\MuM ν\\nuν $\\nu$ ν\\nuν N\\NuN $\\Nu$ N\\NuN ξ\\xiξ $\\xi$ ξ\\xiξ π\\piπ $\\pi$ π\\piπ ϖ\\varpiϖ $\\varpi$ ϖ\\varpiϖ ρ\\rhoρ $\\rho$ ρ\\rhoρ P\\RhoP $\\Rho$ P\\RhoP ϱ\\varrhoϱ $\\varrho$ ϱ\\varrhoϱ σ\\sigmaσ $\\sigma$ σ\\sigmaσ Σ\\SigmaΣ $\\Sigma$ Σ\\SigmaΣ ς\\varsigmaς $\\varsigma$ ς\\varsigmaς τ\\tauτ $\\tau$ τ\\tauτ T\\TauT $\\Tau$ T\\TauT υ\\upsilonυ $\\upsilon$ υ\\upsilonυ ϕ\\phiϕ $\\phi$ ϕ\\phiϕ Φ\\PhiΦ $\\Phi$ Φ\\PhiΦ φ\\varphiφ $\\varphi$ φ\\varphiφ χ\\chiχ $\\chi$ χ\\chiχ X\\ChiX $\\Chi$ X\\ChiX ψ\\psiψ $\\psi$ ψ\\psiψ Ψ\\PsiΨ $\\Psi$ Ψ\\PsiΨ ω\\omegaω $\\omega$ ω\\omegaω Ω\\OmegaΩ $\\Omega$ Ω\\OmegaΩ ϝ\\digammaϝ $\\digamma$ ϝ\\digammaϝ ϰ\\varkappaϰ $\\varkappa$ ϰ\\varkappaϰ 上划线、中划线、下划线 符号 代码 表现 上划线 $\\overline{\\text{a}}$ a‾\\overline{\\text{a}}a 中划线 $\\underline{\\text{a}}$ a‾\\underline{\\text{a}}a​ 下划线 $\\underline{\\underline{\\text{a}}}$ a‾‾\\underline{\\underline{\\text{a}}}a​​ 括号 符号 代码 表现 小括号 $(a)$ (a)(a)(a) 括号 $\\left(a\\right)$ (a)\\left(a\\right)(a) 中括号 $[a]$ [a][a][a] 中括号 $\\left[a\\right]$ [a]\\left[a\\right][a] 大括号 ${a}$ a{a}a 大括号 $\\left\\{a\\right\\}$ {a}\\left\\{a\\right\\}{a} 尖括号 $\\langle a \\rangle$ ⟨a⟩\\langle a \\rangle⟨a⟩ 尖括号 $\\left\\langle a \\right\\rangle$ ⟨a⟩\\left\\langle a \\right\\rangle⟨a⟩ 分数 符号 代码 表现 分数 $\\frac{a}{b}$ ab\\frac{a}{b}ba​ 分数 ${a \\over b}$ ab{a \\over b}ba​ 分数 $\\dfrac{a}{b}$ ab\\dfrac{a}{b}ba​ 分数 $\\tfrac{a}{b}$ ab\\tfrac{a}{b}ba​ 指数和下标 符号 代码 表现 上标 $a^b$ aba^bab 下标 $a_b$ aba_bab​ 上下标 $a^{b}_c$ acba^{b}_cacb​ 根号 符号 代码 表现 根号 $\\sqrt{a}$ a\\sqrt{a}a​ 根号 $\\sqrt[n]{a}$ an\\sqrt[n]{a}na​ 矢量 符号 代码 表现 矢量 $\\vec{a}$ a⃗\\vec{a}a 矢量 $\\overrightarrow{a}$ a→\\overrightarrow{a}a 矢量 $\\overleftarrow{a}$ a←\\overleftarrow{a}a 矩阵 符号 代码 表现 矩阵 $\\begin{matrix} a &amp; b \\\\ c &amp; d \\end{matrix}$ abcd\\begin{matrix} a &amp; b \\\\ c &amp; d \\end{matrix}ac​bd​ 矩阵 $\\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix}$ (abcd)\\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix}(ac​bd​) 矩阵 $\\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}$ [abcd]\\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}[ac​bd​] 矩阵 $\\begin{Bmatrix} a &amp; b \\\\ c &amp; d \\end{Bmatrix}$ {abcd}\\begin{Bmatrix} a &amp; b \\\\ c &amp; d \\end{Bmatrix}{ac​bd​} 矩阵 $\\begin{vmatrix} a &amp; b \\\\ c &amp; d \\end{vmatrix}$ ∣abcd∣\\begin{vmatrix} a &amp; b \\\\ c &amp; d \\end{vmatrix}∣∣∣∣∣​ac​bd​∣∣∣∣∣​ 矩阵 $\\begin{Vmatrix} a &amp; b \\\\ c &amp; d \\end{Vmatrix}$ ∥abcd∥\\begin{Vmatrix} a &amp; b \\\\ c &amp; d \\end{Vmatrix}∥∥∥∥∥​ac​bd​∥∥∥∥∥​ 逻辑运算符 符号 代码 表现 与 $\\land$ ∧\\land∧ 或 $\\lor$ ∨\\lor∨ 并 $\\bigvee$ ⋁\\bigvee⋁ 交 $\\bigwedge$ ⋀\\bigwedge⋀ 非 $\\lnot$ ¬\\lnot¬ 集合运算符 符号 代码 表现 属于 $\\in$ ∈\\in∈ 不属于 $\\notin$ ∉\\notin∈/ 子集 $\\subset$ ⊂\\subset⊂ 真子集 $\\subsetneq$ ⊊\\subsetneq⊊ 超集 $\\supset$ ⊃\\supset⊃ 真超集 $\\supsetneq$ ⊋\\supsetneq⊋ 空集 $\\emptyset$ ∅\\emptyset∅ 全集 $\\mathbb{U}$ U\\mathbb{U}U 交集 $\\cap$ ∩\\cap∩ 并集 $\\cup$ ∪\\cup∪ 补集 $\\complement$ ∁\\complement∁ 差集 $\\setminus$ ∖\\setminus∖ 对称差 $\\bigtriangleup$ △\\bigtriangleup△ 交 $\\bigcap$ ⋂\\bigcap⋂ 并 $\\bigcup$ ⋃\\bigcup⋃ 箭头 符号 代码 表现 左箭头 $\\leftarrow$ ←\\leftarrow← 向左粗箭头 $\\Leftarrow$ ⇐\\Leftarrow⇐ 向左长箭头 $\\longleftarrow$ ⟵\\longleftarrow⟵ 向左长粗箭头 $\\Longleftarrow$ ⟸\\Longleftarrow⟸ 右箭头 $\\rightarrow$ →\\rightarrow→ 向右粗箭头 $\\Rightarrow$ ⇒\\Rightarrow⇒ 向右长箭头 $\\longrightarrow$ ⟶\\longrightarrow⟶ 向右长粗箭头 $\\Longrightarrow$ ⟹\\Longrightarrow⟹ 左右箭头 $\\leftrightarrow$ ↔\\leftrightarrow↔ 左右粗箭头 $\\Leftrightarrow$ ⇔\\Leftrightarrow⇔ 上箭头 $\\uparrow$ ↑\\uparrow↑ 下箭头 $\\downarrow$ ↓\\downarrow↓ 向上粗箭头 $\\Uparrow$ ⇑\\Uparrow⇑ 向下粗箭头 $\\Downarrow$ ⇓\\Downarrow⇓ 上下箭头 $\\updownarrow$ ↕\\updownarrow↕ 上下粗箭头 $\\Updownarrow$ ⇕\\Updownarrow⇕ 大型运算符 符号 代码 表现 求和 $\\sum$ ∑\\sum∑ 积分 $\\int$ ∫\\int∫ 积分 $\\oint$ ∮\\oint∮ 乘积 $\\prod$ ∏\\prod∏ 并 $\\bigsqcup$ ⨆\\bigsqcup⨆ 并 $\\biguplus$ ⨄\\biguplus⨄ 并 $\\bigotimes$ ⨂\\bigotimes⨂ 并 $\\bigoplus$ ⨁\\bigoplus⨁ 并 $\\bigodot$ ⨀\\bigodot⨀ 空格与换行 符号 代码 表现 空格 a\\ b a&nbsp;ba\\ ba&nbsp;b 双空格 a\\quad b aba\\quad bab 四空格 a\\qquad b aba\\qquad bab 紧贴 a\\!b a ⁣ba\\!bab 空格 a\\,b a ba\\,bab 空格 a\\;b a ba\\;bab 换行 a\\\\b aba\\\\bab 换行 a\\\\\\\\b aba\\\\\\\\bab 字体 符号 代码 表现 粗体 $\\mathbf{a}$ a\\mathbf{a}a 斜体 $\\mathit{a}$ a\\mathit{a}a 等宽 $\\mathtt{a}$ a\\mathtt{a}a 黑板粗体 $\\mathbb{a}$ a\\mathbb{a}a 手写体 $\\mathcal{a}$ a\\mathcal{a}a 花体 $\\mathfrak{a}$ a\\mathfrak{a}a 空心 $\\mathbb{a}$ a\\mathbb{a}a 粗斜体 $\\mathbf{\\mathit{a}}$ a\\mathbf{\\mathit{a}}a 其他符号 符号 代码 表现 正常省略号 $\\ldots$ …\\ldots… 列省略号 $\\cdots$ ⋯\\cdots⋯ 行省略号 $\\vdots$ ⋮\\vdots⋮ 斜省略号 $\\ddots$ ⋱\\ddots⋱ 标注符号 符号 代码 表现 hat $\\hat{\\text{a}}$ a^\\hat{\\text{a}}a^ bar $\\bar{\\text{a}}$ aˉ\\bar{\\text{a}}aˉ tilde $\\tilde{\\text{a}}$ a~\\tilde{\\text{a}}a~ dot $\\dot{\\text{a}}$ a˙\\dot{\\text{a}}a˙ ddot $\\ddot{\\text{a}}$ a¨\\ddot{\\text{a}}a¨ check $\\check{\\text{a}}$ aˇ\\check{\\text{a}}aˇ breve $\\breve{\\text{a}}$ a˘\\breve{\\text{a}}a˘ acute $\\acute{\\text{a}}$ aˊ\\acute{\\text{a}}aˊ grave $\\grave{\\text{a}}$ aˋ\\grave{\\text{a}}aˋ vec $\\vec{\\text{a}}$ a⃗\\vec{\\text{a}}a overline $\\overline{\\text{a}}$ a‾\\overline{\\text{a}}a underline $\\underline{\\text{a}}$ a‾\\underline{\\text{a}}a​ underline $\\underline{\\underline{\\text{a}}}$ a‾‾\\underline{\\underline{\\text{a}}}a​​ 方程组 符号 代码 表现 方程组 $\\begin{cases} a = b \\\\ c = d \\end{cases}$ {a=bc=d\\begin{cases} a = b \\\\ c = d \\end{cases}{a=bc=d​ 参考资料 多种方法在 Markdown 加入上划线、中划线、下划线 markdown 公式符号大全","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.mryan2005.top/categories/Markdown/"},{"name":"Latex","slug":"Markdown/Latex","permalink":"https://www.mryan2005.top/categories/Markdown/Latex/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://www.mryan2005.top/tags/Latex/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.mryan2005.top/tags/Markdown/"}]},{"title":"碎碎念（2）","slug":"suisuinian-2","date":"2024-05-25T17:20:05.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/d59c4914.html","permalink":"https://www.mryan2005.top/posts/d59c4914.html","excerpt":"有时候想想啊，这计算机学多好才叫好。","text":"有时候想想啊，这计算机学多好才叫好。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://www.mryan2005.top/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"矩阵的特征值","slug":"juzhendetezhengzhi","date":"2024-05-25T14:42:07.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/816f0c9a.html","permalink":"https://www.mryan2005.top/posts/816f0c9a.html","excerpt":"特征多项式 特征多项式是指 f(λ)=∣A−λE∣f(\\lambda) = |A - λE|f(λ)=∣A−λE∣。 依然，还是上面的例子，特征多项式是 (λ−4)(λ+2)(λ-4)(λ+2)(λ−4)(λ+2)","text":"特征多项式 特征多项式是指 f(λ)=∣A−λE∣f(\\lambda) = |A - λE|f(λ)=∣A−λE∣。 依然，还是上面的例子，特征多项式是 (λ−4)(λ+2)(λ-4)(λ+2)(λ−4)(λ+2) 特征方程 特征方程是指∣A−λE∣=0|A - λE| = 0∣A−λE∣=0 还是上面的例子，特征方程是 λ2−2λ−8=0λ^2 - 2λ - 8 = 0λ2−2λ−8=0 特征值 n 阶方阵 A 的特征值是指数 λ，使得线性方程组 (A−λE)x=0(A - λE)x = 0(A−λE)x=0 有非零解。特征值 λ 是方程∣A−λE∣=0|A - λE| = 0∣A−λE∣=0 的根。 E 是单位矩阵，即 E=[100⋯0010⋯0001⋯0⋮⋮⋮⋱⋮000⋯1]E = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 1 \\end{bmatrix}E=⎣⎢⎢⎢⎢⎢⎢⎡​100⋮0​010⋮0​001⋮0​⋯⋯⋯⋱⋯​000⋮1​⎦⎥⎥⎥⎥⎥⎥⎤​ 例题 我们先来个简单点的 ——2 阶方阵。（例 1） 求矩阵 [315−1]\\begin{bmatrix} 3 &amp; 1 \\\\ 5 &amp; -1 \\end{bmatrix}[35​1−1​] 的特征值。 解： ∣A−λE∣=∣3−λ15−1−λ∣=(3−λ)(−1−λ)−5=λ2−2λ−8=0|A - λE| = \\begin{vmatrix} 3-λ &amp; 1 \\\\ 5 &amp; -1-λ \\end{vmatrix} = (3-λ)(-1-λ) - 5 = λ^2 - 2λ - 8 = 0∣A−λE∣=∣∣∣∣∣​3−λ5​1−1−λ​∣∣∣∣∣​=(3−λ)(−1−λ)−5=λ2−2λ−8=0 解得 λ = 4, -2 现在，我们抬升难度 ——3 阶方阵（例 2） 求矩阵 [−211020−413]\\begin{bmatrix} -2 &amp; 1 &amp; 1 \\\\ 0 &amp; 2 &amp; 0 \\\\ -4 &amp; 1 &amp; 3 \\end{bmatrix}⎣⎢⎡​−20−4​121​103​⎦⎥⎤​的特征值。 解： ∣λE−A∣=∣λ+2−1−10λ−204−1λ−3∣=(λ+1)(λ−2)(λ−2)=0|\\lambda E - A| = \\begin{vmatrix} \\lambda + 2 &amp; -1 &amp; -1 \\\\ 0 &amp; \\lambda - 2 &amp; 0 \\\\ 4 &amp; -1 &amp; \\lambda - 3 \\end{vmatrix} = (\\lambda + 1)(\\lambda - 2)(\\lambda - 2) = 0∣λE−A∣=∣∣∣∣∣∣∣​λ+204​−1λ−2−1​−10λ−3​∣∣∣∣∣∣∣​=(λ+1)(λ−2)(λ−2)=0 解得 λ = -1, 2, 2 总结 由此，我们可以知道，求特征值的步骤是： 求特征方程 解特征方程 得到特征值 特征向量 依旧是上面的（例 1），当 λ = 4 时，对应的特征向量应该满足 (A−4E)x=0(A - 4E)x = 0(A−4E)x=0，即 {−5x1+x2=05x1−5x2=0\\left\\{\\begin{matrix} -5x_1 + x_2 &amp;= 0 \\\\ 5x_1 - 5x_2 &amp;= 0 \\end{matrix} \\right. {−5x1​+x2​5x1​−5x2​​=0=0​，解得 x1=x2x_1 = x_2x1​=x2​，所以特征向量是 p1=[11]p_1 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}p1​=[11​]，而 kp1kp_1kp1​ （k 为非零常数）也就是对应于 λ1=4\\lambda_1 = 4λ1​=4 的全部特征向量。 当 λ = -2 时，对应的特征向量应该满足 (A+2E)x=0(A + 2E)x = 0(A+2E)x=0，即 {−5x1−x2=0−5x1−x2=0\\left\\{\\begin{matrix} -5x_1 -x_2 &amp;= 0 \\\\ -5x_1 - x_2 &amp;= 0 \\end{matrix} \\right. {−5x1​−x2​−5x1​−x2​​=0=0​，解得 x1=−x2x_1 = -x_2x1​=−x2​，所以特征向量是 p2=[1−5]p_2 = \\begin{bmatrix} 1 \\\\ -5 \\end{bmatrix}p2​=[1−5​]，而 kp2kp_2kp2​（k 为非零常数）也就是对应于 λ2=−2\\lambda_2 = -2λ2​=−2 的全部特征向量。 而（例 2），我们知道特征值是 - 1, 2, 2。 当 λ = -1 时，对应的特征向量应该满足 (A+E)x=0(A + E)x = 0(A+E)x=0，可以得到基础解系为 [101]\\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}⎣⎢⎡​101​⎦⎥⎤​，所以特征向量是 p1=[101]p_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}p1​=⎣⎢⎡​101​⎦⎥⎤​，而 kp1kp_1kp1​（k 为非零常数）也就是对应于 λ1=−1\\lambda_1 = -1λ1​=−1 的全部特征向量。 当 λ = 2 时，对应的特征向量应该满足 (A−2E)x=0(A - 2E)x = 0(A−2E)x=0，即 2E−A=[4−1−10004−1−1]→[1−14−14000000]2E-A=\\begin{bmatrix} 4 &amp; -1 &amp; -1 \\\\ 0 &amp; 0 &amp; 0 \\\\ 4 &amp; -1 &amp; -1 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 1 &amp; -\\frac{1}{4} &amp; -\\frac{1}{4} \\\\ 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix}2E−A=⎣⎢⎡​404​−10−1​−10−1​⎦⎥⎤​→⎣⎢⎡​100​−41​00​−41​00​⎦⎥⎤​，可以得到基础解系为 p2=[140],p3=[104]p_2 = \\begin{bmatrix} 1 \\\\ 4 \\\\ 0 \\end{bmatrix}, p_3 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 4 \\end{bmatrix}p2​=⎣⎢⎡​140​⎦⎥⎤​,p3​=⎣⎢⎡​104​⎦⎥⎤​，所以 λ=2 的全体特征向量为 k2p2+k3p3\\lambda = 2 的全体特征向量为 k_2p_2 + k_3p_3λ=2 的全体特征向量为 k2​p2​+k3​p3​ （k2,k3k_2, k_3k2​,k3​不同时为 0）。 性质 n 阶矩阵 A 与它的转置矩阵 ATA^TAT 有相同的特征值。 设 A=(aij)A=(a_{ij})A=(aij​) 是 n 阶矩阵，则 f(λ)=∣λE−A∣=λn−∑i=1naiiλn−1+……+(−1)kSkλn−k+……+(−1)n∣A∣f(\\lambda) = |\\lambda E - A| = \\lambda^n - \\sum_{i=1}^{n}a_{ii}\\lambda^{n-1} + …… + (-1)^kS_k\\lambda^{n-k} + …… + (-1)^n|A|f(λ)=∣λE−A∣=λn−∑i=1n​aii​λn−1+……+(−1)kSk​λn−k+……+(−1)n∣A∣，其中 SkS_kSk​是 A 的 k 阶主子式。 k 阶主子式 = ∣Ak∣=∣a11a12⋯a1ka21a22⋯a2k⋮⋮⋱⋮ak1ak2⋯akk∣|A_k| = \\begin{vmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1k} \\\\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2k} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{k1} &amp; a_{k2} &amp; \\cdots &amp; a_{kk} \\end{vmatrix}∣Ak​∣=∣∣∣∣∣∣∣∣∣∣​a11​a21​⋮ak1​​a12​a22​⋮ak2​​⋯⋯⋱⋯​a1k​a2k​⋮akk​​∣∣∣∣∣∣∣∣∣∣​ 由上可知，λ1+λ2+……+λn=a11+a22+……+ann\\lambda_1 + \\lambda_2 + …… + \\lambda_n = a_{11} + a_{22} + …… + a_{nn}λ1​+λ2​+……+λn​=a11​+a22​+……+ann​ λ1λ2……λn=∣A∣\\lambda_1\\lambda_2……\\lambda_n = |A|λ1​λ2​……λn​=∣A∣，其中，A 的全体特征值的和等于 A 的主对角线元素之和，称为 A 的迹。 至于迹的用处，看下面例题吧 设 A=[5−181−1]A = \\begin{bmatrix} 5 &amp; -18 \\\\ 1 &amp; -1 \\end{bmatrix}A=[51​−18−1​]，则有 det(A)=−5+18=13det(A) = -5 + 18 = 13det(A)=−5+18=13，tr(A)=5−1=4tr(A) = 5 - 1 = 4tr(A)=5−1=4。 而多项式就是 f(λ)=λ2−4λ+13f(\\lambda) = \\lambda^2 - 4\\lambda + 13f(λ)=λ2−4λ+13。","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"矩阵","slug":"线性代数/矩阵","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/"}],"tags":[{"name":"向量","slug":"向量","permalink":"https://www.mryan2005.top/tags/%E5%90%91%E9%87%8F/"},{"name":"矩阵","slug":"矩阵","permalink":"https://www.mryan2005.top/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"使用 “自带栈” 解决中序遍历（2）","slug":"zidaizhanjiejueerchashuzhongxubianli-2","date":"2024-05-25T13:12:50.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/fbed3bd6.html","permalink":"https://www.mryan2005.top/posts/fbed3bd6.html","excerpt":"Problem: 94. 二叉树的中序遍历 思路 我们都知道中序遍历是左边 ——&gt; 中间 ——&gt; 右边 解题方法 一直向左边走 到达左边尽头后弹出并打印，然后向右边走一个。 继续一直向左边走。 到达左边尽头后弹出并打印，然后向右边走一个。 结束条件是 p 和栈 S 都为空。 复杂度 时间复杂度: O(n)O(n)O(n) 空间复杂度:","text":"Problem: 94. 二叉树的中序遍历 思路 我们都知道中序遍历是左边 ——&gt; 中间 ——&gt; 右边 解题方法 一直向左边走 到达左边尽头后弹出并打印，然后向右边走一个。 继续一直向左边走。 到达左边尽头后弹出并打印，然后向右边走一个。 结束条件是 p 和栈 S 都为空。 复杂度 时间复杂度: O(n)O(n)O(n) 空间复杂度: O(n)O(n)O(n) Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; *//** * Note: The returned array must be malloced, assume caller calls free(). */typedef struct StackNode { struct TreeNode **TreeNode; struct StackNode *next;} StackNode, *Stack;void Push(Stack *S, struct TreeNode **tNode) { StackNode *SN = (StackNode*)malloc(sizeof(StackNode)); SN-&gt;TreeNode = tNode; if(!*S) { SN-&gt;next = NULL; (*S) = SN; } else { SN-&gt;next = *S; *S = SN; }}// 出栈struct TreeNode **Pop(Stack *S) { if(*S) { struct TreeNode **p = (*S)-&gt;TreeNode; StackNode *q = *S; (*S) = (*S)-&gt;next; free(q); return p; } else return NULL;}int* inorderTraversal(struct TreeNode* root, int* returnSize) { Stack S = NULL; struct TreeNode *p = root; int *a = (int*)malloc(sizeof(int) * 100), *q = a; if(root) Push(&amp;S, &amp;root); while(p || S) { if(p) { if(p-&gt;left) Push(&amp;S, &amp;p-&gt;left); p = p-&gt;left; } else { p = *Pop(&amp;S); *(q++) = p-&gt;val; if(p-&gt;right) Push(&amp;S, &amp;p-&gt;right); p = p-&gt;right; } } *returnSize = q - a; return a;}","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mryan2005.top/categories/LeetCode/"},{"name":"简单题","slug":"LeetCode/简单题","permalink":"https://www.mryan2005.top/categories/LeetCode/%E7%AE%80%E5%8D%95%E9%A2%98/"}],"tags":[{"name":"二叉树的中序遍历","slug":"二叉树的中序遍历","permalink":"https://www.mryan2005.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"栈","slug":"栈","permalink":"https://www.mryan2005.top/tags/%E6%A0%88/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.mryan2005.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"点估计","slug":"dianguji","date":"2024-05-23T23:29:12.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/6f990142.html","permalink":"https://www.mryan2005.top/posts/6f990142.html","excerpt":"参数估计问题 是指当所研究的总体分布类型已知，但分布中含有一个或多个未知参数时，如何根据样本来估计未知参数的问题。 譬如：一批灯泡寿命的预测，如果将灯泡的寿命 XXX 看作一个总体，根据实际经验知道 XXX 服从正态分布 N(μ,σ2)N(μ,σ2)N(μ,σ2)，但参数 μμμ 与 σ2σ2σ2 是未知的，要想预测灯泡寿命，就必须确定出寿命分布的参数，这就是参数估计问题。 假设所研究的总体类型已知，即其分布函数为 F(x,θ)F(x,θ)F(x,θ)，但其包含的参数 θθθ 为未知参数（θθθ 可以是一个参数，也可以是一个参数向量）。","text":"参数估计问题 是指当所研究的总体分布类型已知，但分布中含有一个或多个未知参数时，如何根据样本来估计未知参数的问题。 譬如：一批灯泡寿命的预测，如果将灯泡的寿命 XXX 看作一个总体，根据实际经验知道 XXX 服从正态分布 N(μ,σ2)N(μ,σ2)N(μ,σ2)，但参数 μμμ 与 σ2σ2σ2 是未知的，要想预测灯泡寿命，就必须确定出寿命分布的参数，这就是参数估计问题。 假设所研究的总体类型已知，即其分布函数为 F(x,θ)F(x,θ)F(x,θ)，但其包含的参数 θθθ 为未知参数（θθθ 可以是一个参数，也可以是一个参数向量）。 概念 设 X1,X2,…,XnX_1, X_2, …, X_nX1​,X2​,…,Xn​是取自总体 X 的一个样本， x1,x2,…,xnx_1, x_2, …, x_nx1​,x2​,…,xn​是相应的一个样本观察值。 θθθ 是总体分布中的未知参数，为估计未知参数 θθθ。 构造一个适当的统计量 θ^(X1,X2,⋯,Xn)\\hat \\theta(X_1,X_2,⋯,X_n)θ^(X1​,X2​,⋯,Xn​)，再用其样本观察值 θ^(x1,x2,⋯,xn)\\hat θ(x_1,x_2,⋯,x_n)θ^(x1​,x2​,⋯,xn​) 来估计 θθθ 的值。 θ^(X1,X2,⋯,Xn)\\hat\\theta(X_1,X_2,⋯,X_n)θ^(X1​,X2​,⋯,Xn​) 为估计量，θ^(x1,x2,⋯,xn)\\hat θ(x_1,x_2,⋯,x_n)θ^(x1​,x2​,⋯,xn​) 是估计值。 在不致混淆的情况下，估计量与估计值统称为点估计，简称为估计。 例题 设 XXX 表示某种型号的电子元件的寿命（以小时计），它服从指数分布 e(1θ)e(\\frac{1}{\\theta})e(θ1​)，其概率密度为 f(x,θ)={0,x&nbsp;=&lt;&nbsp;01θe−1θx,x&nbsp;&gt;&nbsp;0f(x, \\theta) = \\begin{cases} 0, &amp;\\text {x =&lt; 0}\\\\ \\frac{1}{\\theta}e^{-\\frac{1}{\\theta}x}, &amp;\\text {x &gt; 0}\\\\ \\end{cases} f(x,θ)={0,θ1​e−θ1​x,​x&nbsp;=&lt;&nbsp;0x&nbsp;&gt;&nbsp;0​ 其中 θ （ θ &gt; 0）是未知参数，现得样本值为 167, 131, 169, 144, 173, 199, 109, 212, 222, 250，试估计未知参数 θ。 根据指数分布的数字特征可知 θ = E (X)，因此根据点估计的定义，可用样本均值 ¯X 来代替 E (X)，从而得到 θ 的估计量 θ^=x‾\\hat \\theta = \\overline xθ^=x θ^=X‾\\hat θ=\\overline Xθ^=X。然后用样本值求 θθθ 的估计值，得 θ^=110(167+131+169+144+173+199+109+&nbsp;212+&nbsp;222+&nbsp;250)=177.6\\hat θ=\\frac{1}{10}(167+131+169+144+173+199+109+&nbsp;212+&nbsp;222+&nbsp;250)=177.6θ^=101​(167+131+169+144+173+199+109+&nbsp;212+&nbsp;222+&nbsp;250)=177.6。 根据指数分布的方差可知 θ2=D(X)θ^2 = D(X)θ2=D(X)，这样我们也可以将样本方差 S2S^2S2 作为 θ2θ^2θ2 的估计量，即 θ2=S2θ ^2=S^2θ2=S2，可得 θθθ 的估计量 θ^2=S2\\hat\\theta^2 = S^2θ^2=S2，再采用样本值求 θθθ 的估计值 θ^=s=19[(167−177.6)2+⋯(250−177)2]=43.5487\\hat θ=s=\\sqrt{\\frac{1}{9}[(167−177.6)^2+⋯(250−177)^2]}=43.5487θ^=s=91​[(167−177.6)2+⋯(250−177)2]​=43.5487 这可以说明对于一个未知参数的估计量而言，显然不同的样本值得到不同的估计值。 对同一未知参数，其点估计也可以构造不同的统计量而得到，从而得到不同的估计量。 评价估计量好坏的标准 —— 无偏性标准 估计量是随机变量，不同的样本值会得到不同的估计值。 因此，一个基本的标准就是希望估计值在未知参数真值的附近，也就是说，多次估计值的期望是未知参数真值。这就是所谓估计量的无偏性标准。 例题","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://www.mryan2005.top/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"参数估计","slug":"概率论与数理统计/参数估计","permalink":"https://www.mryan2005.top/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"}],"tags":[]},{"title":"链表入门","slug":"linklist-pre","date":"2024-05-23T22:25:31.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/e86a0aed.html","permalink":"https://www.mryan2005.top/posts/e86a0aed.html","excerpt":"链表（linked list）的别称 线性表的链式表示、链式存储结构、链式映像、随机存取结构的储存结构 单向链表 长相 无头链表 指向首元结点的指针叫做头指针（head pointed） 有头链表 第一个结点叫头结点（head node） 结构体定义","text":"链表（linked list）的别称 线性表的链式表示、链式存储结构、链式映像、随机存取结构的储存结构 单向链表 长相 无头链表 指向首元结点的指针叫做头指针（head pointed） 有头链表 第一个结点叫头结点（head node） 结构体定义 12345typedef struct node { ElementType data; struct node *next;} node;typedef node* List; 初始化 123456789101112131415void initList(List *L) { List p = *L; while(p &amp;&amp; p-&gt;next) p = p-&gt;next; if(!p) { *L = (node*)malloc(sizeof(node)); p = *L; scanf(\"%d\", &amp;p-&gt;data); p-&gt;next = NULL; } else { p-&gt;next = (node*)malloc(sizeof(node)); p = p-&gt;next; scanf(\"%d\", &amp;p-&gt;data); p-&gt;next = NULL; }} 增加 行尾增加 :::collapse [代码] 12345678int addNodeFromLast(List *L, ElementType data) { List p = *L; while(p &amp;&amp; p-&gt;next) p = p-&gt;next; p-&gt;next = (node*)malloc(sizeof(node)); p = p-&gt;next; p-&gt;data = data; p-&gt;next = NULL;} ::: 行首增加 :::collapse [代码] 123456int addNodeFromHead(List *L, ElementType data) { node *p = (node*)malloc(sizeof(node)); p-&gt;data = data; p-&gt;next = *L; *L = p;} ::: 中间插入 :::collapse [代码] 12345678910111213int addNodeFromMiddle(List *L, ElementType data, int position) { node *p = *L, *q = (node*)malloc(sizeof(node)); int positionCur = 0; while(position-1 &gt; positionCur) { positionCur++; p = p-&gt;next; if(!p) return 0; } q-&gt;data = data; q-&gt;next = p-&gt;next; p-&gt;next = q; return 1;} ::: 有序插入 原理：找到比它大的数，插在比它大的数的前面 :::collapse [代码] 123456789101112131415void insertNode(List *L, ElementType x) { node *p = (node*)malloc(sizeof(node)), *q = *L, *k = NULL; p-&gt;data = x; while(x &gt; q-&gt;data &amp;&amp; q-&gt;next) { k = q; q = q-&gt;next; } if(q != *L) { p-&gt;next = k-&gt;next; k-&gt;next = p; } else { p-&gt;next = *L; *L = p; }} ::: 删除 通过序号删除 原理：寻找 ——&gt; 删除 :::collapse [代码] 12345678910111213141516int removeNode(List *L, int position) { if(position &lt; 1) return 1; node *p = *L, *q = *L; int curPosition = 1; while(p &amp;&amp; curPosition &lt; position) { curPosition++; q = p; p = p-&gt;next; } if(p) { if(p != *L) q-&gt;next = p-&gt;next; else *L = p-&gt;next; free(p); return 0; } else return 1;} ::: 通过匹配结果删除 原理：寻找（需要删除的位置和需要删除的位置的前一个位置）——&gt; 删除 :::collapse [代码] 12345678910111213141516171819int removeNodeThroughContent(List *L, ElementType data) { node *p = *L, *k = *L; int positionCurrent = 0; while(p &amp;&amp; p-&gt;data != data) { k = p; p = p-&gt;next; } if(p) { if(p != *L) k-&gt;next = p-&gt;next; else *L = p-&gt;next; free(p); return 0; } else { k-&gt;next = NULL; free(p); return 0; } return 1;} ::: 全部删除 :::collapse [代码] 123456789101112int removeAllNode(List *L) { node *p = *L, *k = *L; while(k) { k = p; if(p) { p = p-&gt;next; } free(k); } *L = NULL; return 1;} ::: 返回信息 返回长度 :::collapse [代码] C 123456789int getListLength(sqList List) { int length = 0; node *p = List; while(p) { p = p-&gt;next; length++; } return length;} Python 1def getListLength(List): ::: 返回某一元素的位置 :::collapse [代码] 123456789```:::### 返回某一位置元素的信息:::collapse[代码]```c ::: 是否是空表 :::collapse [代码] C 123456#define OK 1#define NO 0int isEmpty(sqList List) { if(List) return OK; else return NO;} Python 1def isEmpty(List): ::: 对内部数据进行操作 排序 逆置 方法一 原理 :::collapse [代码] C 123456789101112131415List f(List *L) { List p = *L, L1 = NULL, q = NULL; while(p) { q = p-&gt;next; if(!L1) { L1 = p; L1-&gt;next = NULL; } else { p-&gt;next = L1; L1 = p; } p = q; } return L1;} ::: 方法二 原理 :::collapse [代码] C 1234567891011List f(List *L) { List p = *L, Last = *L; while(Last-&gt;next) Last = Last-&gt;next; while(p != Last) { *L = (*L)-&gt;next; p-&gt;next = Last-&gt;next; Last-&gt;next = p; p = *L; } return *L;} ::: 作者：Mryan2005 参考资料 数据结构（C 语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"},{"name":"线性结构（线性表）","slug":"数据结构与算法大全/线性结构（线性表）","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%89/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.mryan2005.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"杨氏双缝干涉","slug":"yangshishangfengganshe","date":"2024-05-21T21:01:42.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/d83f0373.html","permalink":"https://www.mryan2005.top/posts/d83f0373.html","excerpt":"","text":"d 表示两缝间距，D 表示缝到屏幕的距离，λ 表示光波长，x 表示屏幕上的某一点到中心的距离。O 点处表示中央明纹，在 O 点两侧，与 k=1,2,3,……k=1,2,3, ……k=1,2,3,…… 相应的 xkx_kxk​处的 Δr\\Delta rΔr 分别是 ±λ,±2λ,±3λ,……\\plusmn\\lambda, \\plusmn2\\lambda, \\plusmn3\\lambda, ……±λ,±2λ,±3λ,……，分别称为一级明纹、二级明纹、三级明纹，……。 明纹与暗纹 明纹表示的是两束光干涉加强，暗纹表示的是两束光干涉减弱。 波程差 Δr=r2−r1=dsin⁡θ=±kλ&nbsp;(k=1,……)Δr = r_2-r_1 = d\\sinθ = \\plusmn k\\lambda \\ (k = 1, ……)Δr=r2​−r1​=dsinθ=±kλ&nbsp;(k=1,……) 由于 D&gt;&gt;dD&gt;&gt;dD&gt;&gt;d，所以 sin⁡θ=tan⁡θ=x/D\\sin\\theta = \\tan\\theta = x/Dsinθ=tanθ=x/D 所以 dxD=±kλ&nbsp;(k=1,……)d\\frac{x}{D} = \\plusmn k\\lambda \\ (k = 1, …… )dDx​=±kλ&nbsp;(k=1,……) 这是用于计算明纹中心的，计算暗纹中心时，dxD=λ2(2k+1)&nbsp;(k=0,……)d\\frac{x}{D} = \\frac{\\lambda}{2}(2k+1) \\ (k = 0, ……)dDx​=2λ​(2k+1)&nbsp;(k=0,……) 同时这也是第 k 级明纹的中心坐标计算公式，即 xk=kλDd&nbsp;或&nbsp;xk=λ2(2k+1)Ddx_k = k\\lambda\\frac {D}{d} \\ 或 \\ x_k = \\frac {\\lambda}{2}(2k+1)\\frac {D}{d} xk​=kλdD​&nbsp;或&nbsp;xk​=2λ​(2k+1)dD​ 相邻明纹或暗纹间距 相邻明纹或暗纹间距为 Δx=xa−xb=λ[a−b]Dd\\Delta x = x_{a} - x_b = \\lambda [a-b]\\frac{D}{d}Δx=xa​−xb​=λ[a−b]dD​ 光强分布 I=I1+I2+2I1I2cos⁡ΔφI = I_1 + I_2 + 2\\sqrt{I_1I_2}\\cos\\Delta\\varphiI=I1​+I2​+2I1​I2​​cosΔφ 光程和光程差 光程是光波传播的距离，光程差是两束光波传播的距离差。 光程差的计算公式是光程差为几何光程乘以折射率之差，即 Δ=n2r2−n1r1\\Delta = n_2r_2-n_1r_1Δ=n2​r2​−n1​r1​，其中 n 是介质的折射率。 光程差与相位差 光程差与相位差的关系是 Δφ=2πλΔ\\Delta\\varphi = \\frac{2\\pi}{\\lambda}\\DeltaΔφ=λ2π​Δ（这个公式很重要） 所以，我们可以知道这个 ±kλ\\plusmn k\\lambda±kλ 和 ±λ2(2k+1)\\plusmn\\frac{\\lambda}{2}(2k+1)±2λ​(2k+1) 的推导也是通过 Δφ=2kπ\\Delta\\varphi = 2k\\piΔφ=2kπ 和 Δφ=(2k+1)π\\Delta\\varphi = (2k+1)\\piΔφ=(2k+1)π 推导出来的。 当然，这可以联系到之前的波程差与相位差的关系，即 Δφ=2πλΔx\\Delta\\varphi = \\frac{2\\pi}{\\lambda}\\Delta xΔφ=λ2π​Δx 其实，由上面的公式可以推导出以下关系 Δ=±kλ\\Delta = \\plusmn k\\lambdaΔ=±kλ 时，干涉加强（最强）。 Δ=±λ2(2k+1)\\Delta = \\plusmn\\frac{\\lambda}{2}(2k+1)Δ=±2λ​(2k+1) 时，干涉减弱（最弱）。 这也和波动中的叠加原理相符。 如何使干涉条纹间距发生变化 首先，我们要知道，干涉条纹间距的公式是 Δx=λ[a−b]Dd\\Delta x = \\lambda [a-b]\\frac{D}{d}Δx=λ[a−b]dD​和图示 我们可以通过改变 λ\\lambdaλ、DDD、ddd 中的任意一个来改变干涉条纹间距。 由此，我们可以通过改变光源的波长、改变屏幕到缝的距离、改变两缝间的距离来改变干涉条纹间距使其变大或变小。 至于将装置从一个环境转移到另一个环境，干涉条纹间距是不变的。 劳埃德镜 半波损失 当入射光从折射率较小的光疏介质投射到折射率较大的光密介质表面时，反射光比入射光有 π\\piπ 的相位突变，这使得反射光与入射光之间附加了半个波长（λ2\\frac{\\lambda}{2}2λ​）的相位差，这一现象称为半波损失。","categories":[{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"光学","slug":"物理/光学","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E5%85%89%E5%AD%A6/"}],"tags":[]},{"title":"剪辑入门","slug":"jianjirumen","date":"2024-05-21T08:50:32.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/171c39b7.html","permalink":"https://www.mryan2005.top/posts/171c39b7.html","excerpt":"软件的选择","text":"软件的选择","categories":[{"name":"剪辑","slug":"剪辑","permalink":"https://www.mryan2005.top/categories/%E5%89%AA%E8%BE%91/"}],"tags":[]},{"title":"重新排列数组","slug":"congxingpailieshuzu","date":"2024-05-20T17:18:08.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/95f3cae3.html","permalink":"https://www.mryan2005.top/posts/95f3cae3.html","excerpt":"Problem: 1470. 重新排列数组 思路 由题可知，x 的部分被放在 0~n/2-1 处，y 的部分放在 n/2~n 处，而重排是按照 [x1,y1,……,xn,yn][x_1, y_1, ……, x_n, y_n][x1​,y1​,……,xn​,yn​] 摆放。","text":"Problem: 1470. 重新排列数组 思路 由题可知，x 的部分被放在 0~n/2-1 处，y 的部分放在 n/2~n 处，而重排是按照 [x1,y1,……,xn,yn][x_1, y_1, ……, x_n, y_n][x1​,y1​,……,xn​,yn​] 摆放。 解题方法 解题方法如 Code 所示。 复杂度 时间复杂度: O(n)O(n)O(n) 空间复杂度: O(n)O(n)O(n) Code []1234567int* shuffle(int* nums, int numsSize, int n, int* returnSize){ int *q = (int*)malloc(sizeof(int)*2*n); *returnSize = 2*n; for(int i = 0, p = 0; i &lt; numsSize/2; i++, p += 2) q[p] = nums[i]; for(int i = numsSize/2, p = 1; i &lt; numsSize; i++, p += 2) q[p] = nums[i]; return q;}","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mryan2005.top/categories/LeetCode/"},{"name":"简单题","slug":"LeetCode/简单题","permalink":"https://www.mryan2005.top/categories/LeetCode/%E7%AE%80%E5%8D%95%E9%A2%98/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://www.mryan2005.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"我为什么要创建我的博客","slug":"the_reason_why_I_create_my_blog","date":"2024-05-20T17:18:08.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/960aa022.html","permalink":"https://www.mryan2005.top/posts/960aa022.html","excerpt":"","text":"其实，我们都知道计算机界的大佬都是有一个属于自己的博客，并且他们的博客都是自己搭建的。这是因为他们知道，一个人的知识是有限的，而一个团队的知识是无限的。所以，他们会把自己的知识分享出来，让更多的人来帮助他们完善自己的知识体系。 我的梦想就是成为一个计算机界的大佬，所以我也要创建一个自己的博客，来记录自己的学习历程，分享自己的知识。 这让我想起了我在我的高中的数学老师的 QQ 说说的下面的对于 “冒险的梦想” 的回复： 我想成为想要我的计算机的学识与 Linus Torvalds 相当的人。 我想，这就是我为什么要创建我的博客的原因吧。 我会在这里发表我对计算机的知识的整理，其实，也不只是计算机的知识，我还会发表我对于其他领域的知识的整理。希望我的博客能够帮助到你。 最后，伴随着这首歌，我大喊着 “向顶峰奔去”。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://www.mryan2005.top/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://www.mryan2005.top/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"相干光","slug":"xianggangunag","date":"2024-05-19T16:08:15.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/48b27268.html","permalink":"https://www.mryan2005.top/posts/48b27268.html","excerpt":"形成条件 由频率相同、振动方向相同、相位差恒定的光源发出的光波，经过叠加后，光强呈现明显的周期性变化，这种光波称为相干光。","text":"形成条件 由频率相同、振动方向相同、相位差恒定的光源发出的光波，经过叠加后，光强呈现明显的周期性变化，这种光波称为相干光。 干涉现象 在两个相干光波相遇的区域内，有的点振动始终加强，有的点振动始终减弱或完全抵消，这种现象称为干涉现象。 相干光源 就是能产生相干光的光源。","categories":[{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"光学","slug":"物理/光学","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E5%85%89%E5%AD%A6/"}],"tags":[]},{"title":"有效的括号的栈思想","slug":"youxiaokuohaodezhansixiang","date":"2024-05-19T13:07:11.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/a5285d9d.html","permalink":"https://www.mryan2005.top/posts/a5285d9d.html","excerpt":"Problem: 20. 有效的括号 思路 Mryan2005，觉得要先将不相干的先入栈，然后，当遇到相关的括号时，出栈。 解题方法 有思路可得 复杂度 时间复杂度: O(n)O(n)O(n) 空间复杂度:","text":"Problem: 20. 有效的括号 思路 Mryan2005，觉得要先将不相干的先入栈，然后，当遇到相关的括号时，出栈。 解题方法 有思路可得 复杂度 时间复杂度: O(n)O(n)O(n) 空间复杂度: O(n)O(n)O(n) Code []12345678910111213141516171819202122232425262728293031323334typedef struct stackNode { char data; struct stackNode *next;} stackNode, *Stack;void Push(Stack *S, char data) { stackNode *p = (stackNode*)malloc(sizeof(stackNode)); p-&gt;data = data; p-&gt;next = *S; *S = p;}char GetHead(Stack S) {return S? S-&gt;data: 0;}char Pop(Stack *S) { char data; stackNode *p = *S; data = p-&gt;data; *S = (*S)-&gt;next; free(p); return data;}bool isValid(char* s) { Stack S = NULL; for(char *p = s, c; *p != 0; p++) { if(S) { c = GetHead(S); if(c == '(' &amp;&amp; *p == ')') Pop(&amp;S); else if(c == '[' &amp;&amp; *p == ']') Pop(&amp;S); else if(c == '{' &amp;&amp; *p == '}') Pop(&amp;S); else Push(&amp;S, *p); } else Push(&amp;S, *p); } if(!S) return true; else return false;}","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mryan2005.top/categories/LeetCode/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"https://www.mryan2005.top/tags/Stack/"}]},{"title":"简谐运动的合成","slug":"jianxieyundongdehecheng","date":"2024-05-18T23:57:27.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/374524ff.html","permalink":"https://www.mryan2005.top/posts/374524ff.html","excerpt":"同方向同频率合成 相位差为 2kπ(k=0,±1,±2,±3,……)2k\\pi(k=0, \\plusmn1, \\plusmn2, \\plusmn3, ……)2kπ(k=0,±1,±2,±3,……) 我们可以这样计算振幅 A： A=A12+A22+2A1A2cos⁡Δφ=A12+A22+2A1A2=(A1+A2)2=A1+A2\\begin{aligned} A &amp;= \\sqrt{A_1^2 + A_2^2 + 2A_1A_2\\cos\\Delta\\varphi} \\\\ &amp;= \\sqrt{A_1^2 + A_2^2 + 2A_1A_2} \\\\ &amp;= \\sqrt{(A_1 + A_2)^2} \\\\ &amp;= A_1 + A_2 \\\\ \\end{aligned} A​=A12​+A22​+2A1​A2​cosΔφ​=A12​+A22​+2A1​A2​​=(A1​+A2​)2​=A1​+A2​​ 相位差为 (2k+1)π(k=0,±1,±2,±3,……)(2k+1)\\pi(k=0, \\plusmn1, \\plusmn2, \\plusmn3, ……)(2k+1)π(k=0,±1,±2,±3,……) 我们可以这样计算振幅 A： A=A12+A22+2A1A2cos⁡Δφ=A12+A22−2A1A2=(A1−A2)2=∣A1−A2∣\\begin{aligned} A &amp;= \\sqrt{A_1^2 + A_2^2 + 2A_1A_2\\cos\\Delta\\varphi} \\\\ &amp;= \\sqrt{A_1^2 + A_2^2 - 2A_1A_2} \\\\ &amp;= \\sqrt{(A_1 - A_2)^2} \\\\ &amp;= | A_1 - A_2 | \\\\ \\end{aligned} A​=A12​+A22​+2A1​A2​cosΔφ​=A12​+A22​−2A1​A2​​=(A1​−A2​)2​=∣A1​−A2​∣​ 当相位差取任意值（不是 2kπ2k\\pi2kπ 或 (2k+1)π(2k+1)\\pi(2k+1)π）时，合成振动的振幅在 A1+A2A_1+A_2A1​+A2​和∣A1−A2∣|A_1 - A_2|∣A1​−A2​∣之间 合振幅的计算为：","text":"同方向同频率合成 相位差为 2kπ(k=0,±1,±2,±3,……)2k\\pi(k=0, \\plusmn1, \\plusmn2, \\plusmn3, ……)2kπ(k=0,±1,±2,±3,……) 我们可以这样计算振幅 A： A=A12+A22+2A1A2cos⁡Δφ=A12+A22+2A1A2=(A1+A2)2=A1+A2\\begin{aligned} A &amp;= \\sqrt{A_1^2 + A_2^2 + 2A_1A_2\\cos\\Delta\\varphi} \\\\ &amp;= \\sqrt{A_1^2 + A_2^2 + 2A_1A_2} \\\\ &amp;= \\sqrt{(A_1 + A_2)^2} \\\\ &amp;= A_1 + A_2 \\\\ \\end{aligned} A​=A12​+A22​+2A1​A2​cosΔφ​=A12​+A22​+2A1​A2​​=(A1​+A2​)2​=A1​+A2​​ 相位差为 (2k+1)π(k=0,±1,±2,±3,……)(2k+1)\\pi(k=0, \\plusmn1, \\plusmn2, \\plusmn3, ……)(2k+1)π(k=0,±1,±2,±3,……) 我们可以这样计算振幅 A： A=A12+A22+2A1A2cos⁡Δφ=A12+A22−2A1A2=(A1−A2)2=∣A1−A2∣\\begin{aligned} A &amp;= \\sqrt{A_1^2 + A_2^2 + 2A_1A_2\\cos\\Delta\\varphi} \\\\ &amp;= \\sqrt{A_1^2 + A_2^2 - 2A_1A_2} \\\\ &amp;= \\sqrt{(A_1 - A_2)^2} \\\\ &amp;= | A_1 - A_2 | \\\\ \\end{aligned} A​=A12​+A22​+2A1​A2​cosΔφ​=A12​+A22​−2A1​A2​​=(A1​−A2​)2​=∣A1​−A2​∣​ 当相位差取任意值（不是 2kπ2k\\pi2kπ 或 (2k+1)π(2k+1)\\pi(2k+1)π）时，合成振动的振幅在 A1+A2A_1+A_2A1​+A2​和∣A1−A2∣|A_1 - A_2|∣A1​−A2​∣之间 合振幅的计算为： A=A12+A22+2A1A2cos⁡φ\\begin{aligned} A &amp;= \\sqrt{A_1^2 + A_2^2 + 2A_1A_2\\cos\\varphi} \\\\ \\end{aligned} A​=A12​+A22​+2A1​A2​cosφ​​ 其中 φ\\varphiφ 是两个振动的相位差。 关于 φ 的计算 相位差为 2kπ(k=0,±1,±2,±3,……)2k\\pi(k=0, \\plusmn1, \\plusmn2, \\plusmn3, ……)2kπ(k=0,±1,±2,±3,……) 由于是同相，所以就是 x=x1+x2x = x_1 + x_2x=x1​+x2​。 由此，我们可以得到： x=A1cos⁡(ωt+φ1)+A2cos⁡(ωt+φ2)=A1cos⁡(ωt)cos⁡(φ1)−A1sin⁡(ωt)sin⁡(φ1)+A2cos⁡(ωt)cos⁡(φ2)−A2sin⁡(ωt)sin⁡(φ2)=[A1cos⁡(φ1)+A2cos⁡(φ2)]cos⁡(ωt)−[A1sin⁡(φ1)+A2sin⁡(φ2)]sin⁡(ωt)\\begin{aligned} x &amp;= A_1\\cos(\\omega t + \\varphi_1) + A_2\\cos(\\omega t + \\varphi_2) \\\\ &amp;= A_1\\cos(\\omega t)\\cos(\\varphi_1) - A_1\\sin(\\omega t)\\sin(\\varphi_1) + A_2\\cos(\\omega t)\\cos(\\varphi_2) - A_2\\sin(\\omega t)\\sin(\\varphi_2) \\\\ &amp;= [A_1\\cos(\\varphi_1) + A_2\\cos(\\varphi_2)]\\cos(\\omega t) - [A_1\\sin(\\varphi_1) + A_2\\sin(\\varphi_2)]\\sin(\\omega t) \\\\ \\end{aligned} x​=A1​cos(ωt+φ1​)+A2​cos(ωt+φ2​)=A1​cos(ωt)cos(φ1​)−A1​sin(ωt)sin(φ1​)+A2​cos(ωt)cos(φ2​)−A2​sin(ωt)sin(φ2​)=[A1​cos(φ1​)+A2​cos(φ2​)]cos(ωt)−[A1​sin(φ1​)+A2​sin(φ2​)]sin(ωt)​","categories":[{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"简谐运动","slug":"物理/简谐运动","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8/"}],"tags":[]},{"title":"旋转矢量","slug":"xuanzhuanshiliang","date":"2024-05-18T17:09:50.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/6e211ebe.html","permalink":"https://www.mryan2005.top/posts/6e211ebe.html","excerpt":"一些位置的相位","text":"一些位置的相位 当相位 ωt+φ=0+2kπ\\omega t+φ=0+2k\\piωt+φ=0+2kπ 时，x=Ax=Ax=A，物体在最大正向位移处。 当相位 ωt+φ=π+2kπ\\omega t+φ=π+2k\\piωt+φ=π+2kπ 时，x=−Ax=-Ax=−A，物体在最大负向位移处。 当相位 ωt+φ=π2+2kπ\\omega t+φ=\\frac{\\pi}{2}+2k\\piωt+φ=2π​+2kπ 时，x=0x=0x=0，物体在平衡位置。 当相位 ωt+φ=3π2+2kπ\\omega t+φ=\\frac{3\\pi}{2} + 2k\\piωt+φ=23π​+2kπ 时，x=0x=0x=0，物体在平衡位置。 当相位 0&lt;ωt+φ&lt;π20 &lt; \\omega t+φ &lt; \\frac{\\pi}{2}0&lt;ωt+φ&lt;2π​ 时， x&gt;0x&gt;0x&gt;0，物体向平衡位置运动。 当相位 π2&lt;ωt+φ&lt;π\\frac{\\pi}{2} &lt; \\omega t+φ &lt; \\pi2π​&lt;ωt+φ&lt;π 时， x&lt;0x&lt;0x&lt;0，物体向负方向最大位移运动。 当相位 π&lt;ωt+φ&lt;3π2\\pi &lt; \\omega t+φ &lt; \\frac{3\\pi}{2}π&lt;ωt+φ&lt;23π​ 时， x&lt;0x&lt;0x&lt;0，物体向平衡位置运动。 当相位 3π2&lt;ωt+φ&lt;2π\\frac{3\\pi}{2} &lt; \\omega t+φ &lt; 2\\pi23π​&lt;ωt+φ&lt;2π 时， x&gt;0x&gt;0x&gt;0，物体向正方向最大位移运动。 相位差 相位差 Δφ\\Delta φΔφ 是两个物体的初相差，即 Δφ=(ωt+φ2)−(ωt+φ1)=φ2−φ1\\Delta φ = (\\omega t+φ_2) - (\\omega t+φ_1) = φ_2 - φ_1Δφ=(ωt+φ2​)−(ωt+φ1​)=φ2​−φ1​。 超前与落后 假如 0&lt;∣Δφ∣=∣φ2−φ1∣⩽π0 \\lt |\\Delta φ| = |φ_2 - φ_1| \\leqslant \\pi0&lt;∣Δφ∣=∣φ2​−φ1​∣⩽π，则称 φ2φ_2φ2​ 超前于 φ1φ_1φ1​。 假如 π&lt;∣Δφ∣⩽2π\\pi &lt; |\\Delta φ| \\leqslant 2\\piπ&lt;∣Δφ∣⩽2π, 则称 φ2φ_2φ2​ 落后于 φ1φ_1φ1​，并且是落后 Δφ−π\\Delta φ - \\piΔφ−π 其实，就是相差小于 π\\piπ 时，后面的超前；相差大于 π\\piπ 时，后面的落后。 同相与反相 当 Δφ=2kπ\\Delta φ = 2k\\piΔφ=2kπ 时，两个物体同相。 当 Δφ=(2k+1)π\\Delta φ = (2k+1)\\piΔφ=(2k+1)π 时，两个物体反相。 如何求力 用 F⃗=−kx⃗=−mω2x⃗\\vec{F} = -k\\vec{x} = -m\\omega^2\\vec{x}F=−kx=−mω2x，其中 x⃗=Acos⁡(ωt+φ)\\vec{x} = A\\cos(\\omega t + φ)x=Acos(ωt+φ)，代入即可。 到某处的最短时间 假设从 x1x_1x1​ 到 x2x_2x2​，我们要这样做: 同时要找最短路径，然后 x1=Acos⁡(ωt1+φ1)x2=Acos⁡(ωt1+φ2)\\begin{aligned} x_1 &amp;= A\\cos(\\omega t_1 + φ_1) \\\\ x_2 &amp;= A\\cos(\\omega t_1 + φ_2) \\end{aligned} x1​x2​​=Acos(ωt1​+φ1​)=Acos(ωt1​+φ2​)​ 求出 t1t_1t1​、t2t_2t2​，然后 t2−t1t_2 - t_1t2​−t1​ 即为最短时间。","categories":[{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"简谐运动","slug":"物理/简谐运动","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8/"}],"tags":[]},{"title":"简谐运动的一些参数","slug":"jianxieyundong-zhenfu-zhouqi-pinglv-xiangwei","date":"2024-05-18T16:32:54.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/ebca20c7.html","permalink":"https://www.mryan2005.top/posts/ebca20c7.html","excerpt":"振幅 A 获取振幅的办法 可以通过图像的最大值或最小值看出，A=∣xmax∣=∣xmin∣A = |x_{max}| = |x_{min}|A=∣xmax​∣=∣xmin​∣。 可以通过初始位移和初始速度求出，A=x02+v02ω2A = \\sqrt{x_0^2+\\frac{v_0^2}{ω^2}}A=x02​+ω2v02​​​。 振幅由初始条件决定，即初始位移和初始速度。 周期与频率（TTT 和 fff） T=2πω=2πmkν=1T=ω2πω=2πνT = \\frac{2π}{\\omega} = 2π\\sqrt{\\frac{m}{k}}\\\\ \\nu = \\frac{1}{T} = \\frac{\\omega}{2\\pi} \\\\ \\omega = 2\\pi \\nu T=ω2π​=2πkm​​ν=T1​=2πω​ω=2πν 周期和频率是由振动系统的特性决定的。 相位 φ 初相位","text":"振幅 A 获取振幅的办法 可以通过图像的最大值或最小值看出，A=∣xmax∣=∣xmin∣A = |x_{max}| = |x_{min}|A=∣xmax​∣=∣xmin​∣。 可以通过初始位移和初始速度求出，A=x02+v02ω2A = \\sqrt{x_0^2+\\frac{v_0^2}{ω^2}}A=x02​+ω2v02​​​。 振幅由初始条件决定，即初始位移和初始速度。 周期与频率（TTT 和 fff） T=2πω=2πmkν=1T=ω2πω=2πνT = \\frac{2π}{\\omega} = 2π\\sqrt{\\frac{m}{k}}\\\\ \\nu = \\frac{1}{T} = \\frac{\\omega}{2\\pi} \\\\ \\omega = 2\\pi \\nu T=ω2π​=2πkm​​ν=T1​=2πω​ω=2πν 周期和频率是由振动系统的特性决定的。 相位 φ 初相位 初相位决定了物体在 t=0t=0t=0 时的位置和速度。 获取初相位的办法 可以通过初始位移和初始速度求出，tanφ=−v0ωx0tanφ = -\\frac{v_0}{ωx_0}tanφ=−ωx0​v0​​。 由 x=Acos⁡(ωt+φ)x = A\\cos(ωt+φ)x=Acos(ωt+φ) 求取。 由 v=−ωAsin⁡(ωt+φ)v = - \\omega A\\sin(ωt+φ)v=−ωAsin(ωt+φ) 求取。 由 ω∗t+φ=θ\\omega*t+φ = \\thetaω∗t+φ=θ 求取。","categories":[{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"简谐运动","slug":"物理/简谐运动","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8/"}],"tags":[]},{"title":"回文数","slug":"LeetCode-huiwenshu","date":"2024-05-18T11:19:15.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/df58b0a0.html","permalink":"https://www.mryan2005.top/posts/df58b0a0.html","excerpt":"Problem: 9. 回文数 思路 先拆分，后对比 解题方法 有思路可知。 复杂度 时间复杂度: O(log2n)O(log_2n)O(log2​n) 空间复杂度:","text":"Problem: 9. 回文数 思路 先拆分，后对比 解题方法 有思路可知。 复杂度 时间复杂度: O(log2n)O(log_2n)O(log2​n) 空间复杂度: O(1) Code 123456789101112bool isPalindrome(int x) { if(x &lt; 0) return false; int divided[40], ListSize; int *p = divided; while(x &gt; 0) { *(p++) = x % 10; x /= 10; } ListSize = p - divided; for(int head = 0, tail = ListSize-1; head &lt; tail; head++, tail--) if(divided[head] != divided[tail]) return false; return true;} 一些碎碎念 有时候，我，Mryan2005，有一种感觉，就是上了大学，但还是逃不过各个学科的考试，基本上只要有一个学科考试，你就得抽出至少一天的时间去准备，这就导致了我很少有时间刷题，但是我还是会坚持下去吧，毕竟，刷题只是为了有一种收剑入鞘的感觉。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mryan2005.top/categories/LeetCode/"},{"name":"简单题","slug":"LeetCode/简单题","permalink":"https://www.mryan2005.top/categories/LeetCode/%E7%AE%80%E5%8D%95%E9%A2%98/"}],"tags":[{"name":"对数字的处理","slug":"对数字的处理","permalink":"https://www.mryan2005.top/tags/%E5%AF%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%A4%84%E7%90%86/"}]},{"title":"2024-05-18 更新日志","slug":"updata1","date":"2024-05-18T08:45:51.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/b5f574ac.html","permalink":"https://www.mryan2005.top/posts/b5f574ac.html","excerpt":"目前将会放弃 Github page，选择使用 Cloudflare page，因为 Github page 的访问速度实在是太慢了，而且还经常被墙，所以我决定放弃 Github page，转而使用 Cloudflare page，这样就可以让大家更快的访问我的博客了。","text":"目前将会放弃 Github page，选择使用 Cloudflare page，因为 Github page 的访问速度实在是太慢了，而且还经常被墙，所以我决定放弃 Github page，转而使用 Cloudflare page，这样就可以让大家更快的访问我的博客了。","categories":[{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/categories/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/tags/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"}]},{"title":"顺序表","slug":"ds-sqList","date":"2024-05-17T12:22:25.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/f35acf61.html","permalink":"https://www.mryan2005.top/posts/f35acf61.html","excerpt":"别称 线性表的顺序表示、顺序存储结构、顺序映像、随机存取结构的储存结构 作用 利用数组的连续存储空间顺序存放线性表的各个元素 a[n-1] 是 a[n] 的直接前趋，a[n+1] 是 a[n] 的直接后继。 结构体代码 第一种写法 1234typedef struct sqList { ElementType Data[MAXSIZE]; int Last;} sqList; Python 1234class LNode: def __init__(self): self.Data = [] self.last = -1","text":"别称 线性表的顺序表示、顺序存储结构、顺序映像、随机存取结构的储存结构 作用 利用数组的连续存储空间顺序存放线性表的各个元素 a[n-1] 是 a[n] 的直接前趋，a[n+1] 是 a[n] 的直接后继。 结构体代码 第一种写法 1234typedef struct sqList { ElementType Data[MAXSIZE]; int Last;} sqList; Python 1234class LNode: def __init__(self): self.Data = [] self.last = -1 第二种写法 1234typedef struct sqList { ElementType Data[MAXSIZE]; int length;} sqList; Python 1234class LNode: def __init__(self): self.Data = [] self.length = 0 第三种写法 1234typedef struct sqlList { ElementType *Data; int length;} sqList; Python 1234567891011121314151617class LNode: def __init__(self): self.Data = None self.length = 0···## 初始化### 通过输入来实现的初始化```cint initList(sqList *List, int n) { if(MAXSIZE &lt; n) return 1; ElementType *p = List-&gt;Data; for(int i = 0; i &lt; n; i++, List-&gt;length = i) scanf(\"%d\", p++); return 0;} Python 123456789101112131415161718192021def initList(List: LNode, n): for i in range(0,n): List.Data.append(int(input())) List.length += 1···### 通过读取文件实现的初始化```cint initList(sqList *List, int n, FILE *fp) { if(MAXSIZE &lt; n || fp == NULL) return 1; ElementType *p = List-&gt;Data; for(int i = 0; i &lt; n; i++, List-&gt;length = i) { if(sizeof(ElementType) == 4) *(p++) = fgetc(fp) - '0'; else if(sizeof(ElementType) == 1) *(p++) = fgetc(fp); if( feof(fp) ) { break ; } } return 0;} 增加 行尾增加 C 1234567int insertNodeFromEnd(sqList *List, int n) { if(MAXSIZE &lt; List-&gt;length+n) return 1; ElementType *p = List-&gt;Data + List-&gt;length; for(int i = 0; i &lt; n; i++) scanf(\"%d\", p++); List-&gt;length = n + List-&gt;length; return 0;} Python 12345678910111213141516171819202122def insertNodeFromEnd(List, n): for i in range(1, n+1): List.Data.append(input()) List.length += 1### 行首增加主要原理就是在添加一个Node时，先将原有的向后移一个，再添加。#### C```cint insertNodeFromHead(sqList *List, int n) { if(MAXSIZE &lt; List-&gt;length+n) return 1; ElementType *p = List-&gt;Data; for(int i = 0; i &lt; n; i++) { for(ElementType *q = List-&gt;Data+List-&gt;length; q != p; q--) *q = *(q-1); scanf(\"%d\", p); List-&gt;length++; } return 0;} Python 1234def insertNodeFromHead(List, n): for i in range(0, n): List.Data.insert(0, input()) List.length += 1 中间插入 C 12345678910111213int insertNodeFromMiddle(sqList *List, int insertPostion, int n) { if(MAXSIZE &lt; insertPostion+n || MAXSIZE &lt; insertPostion || List-&gt;length &lt; insertPostion) { printf(\"insertPostion &gt; List-&gt;length\"); return 1; } ElementType *p = List-&gt;Data + insertPostion; for(int i = 0; i &lt; n; i++) { for(ElementType *q = List-&gt;Data+List-&gt;length; q != p; q--) *q = *(q-1); scanf(\"%d\", p); List-&gt;length++; } return 0;} Python 1234def insertNodeFromMiddle(List, insertPostion, n): for i in range(0, n): List.Data.insert(insertPostion, input()) List.length += 1 有序插入 原理：从后往前找 ——&gt; 比它小的数的后面 C 1234567891011121314int insertANode(List va, ElementType a) { if(va-&gt;length &gt; MaxSize) { printf(\"序列已满\"); return 1; } ElementType *p = va-&gt;data + va-&gt;length-1; while(p != va-&gt;data &amp;&amp; a &lt;= *p) { *(p+1) = *p; p--; } *(p+1) = a; va-&gt;length++; return 0;} 删除 通过序号删除 原理：从后往前找 ——&gt; 比它小的数的后面 C 123int removeNodeThroughPosition(List *L, int position) { } 通过匹配结果删除 原理： C 1234567891011121314int removeNodeThroughContent(List *L, ElementType data) { node *p = *L, *q; int positionCurrent = 0; while(p &amp;&amp; p-&gt;next) { p = p-&gt;next; if(p-&gt;data == data) { q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); return 0; } } return 1;} 从 i 开始删除 k 个 原理： C 1234567int deleteNodeFromItoK(sqList *List, int i, int k) { if(i &gt; List-&gt;length || i+k-1 &gt; List-&gt;length) return 1; int *p = List-&gt;Data+(i-1); for(int *q = List-&gt;Data+i+k-1; q != List-&gt;Data+List-&gt;length; q++, p++) *p = *q; List-&gt;length -= k; return 0;} 全部删除 C 123int deleteAllNodes(sqList *List) { List-&gt;length = 0;} python 12def deleteAllNodes(List): List.length = 0; 修改 通过序号修改 C 123456789int changeValue(sqList *List, int insertPostion, ElementType value) { if(insertPostion &gt; List-&gt;length) { printf(\"insertPostion &gt; List-&gt;length\"); return 1; } ElementType *p = List-&gt;Data+(insertPostion-1); *p = value; return 0;} python 123456def changeValue(List, insertPostion, value): if insertPostion &gt; List.length: print(\"插入位置超过表长\") return 1 List[insertPostion-1] = value return 0 通过匹配结果修改 C 12345678int changeValue(sqList *List, ElementType value1, ElementType value) { for(int i = 0; i &lt; List-&gt;length; i++) if(*(List-&gt;Data+i) == value1) { *(List-&gt;Data+i) = value; return 0; } printf(\"not find\"); return 1;} python 123456def changeValue(List, value1, value2): try: List.Data[List.Data.index(value1)] = value2 except ValueError: print(\"找不到该值\") return 1 返回信息 返回长度 C 123int getListLength(sqList List) { return List.length;} python 12def getListLength(List): return List.length 返回某一元素的位置 C 12345int getThePositionOfNode(sqList List, int value) { ElementType *p = List.Data; for(int i = 0; i &lt; List-&gt;length; i++) if(p[i] == value) return i+1; return -1} Python 123456def getThePositionOfNode(List, int value): try: return List.Data.index(value)+1 except ValueError: print(\"找不到该值\") return 1 返回某一位置元素的信息 C 1234567int getTheContactOfNode(sqList List, int postion) { ElementType *p = List.Data; if(postion &gt; List.length) { return p[postion-1]; } return NULL;} Python 1234def getTheContactOfNode(List, postion): if postion &gt; List.length: return False return List.Data[postion-1] 是否是空表 C 12345#define OK 1#define NO 0int isEmpty(sqList List) { if(List.length) return OK; else return NO; Python 12345def isEmpty(List): if len(List): return 1 else: return 0 获得最大长度 C 123int getMaxSize() { return MAXSIZE;} 对内部数据进行操作 排序 逆置 C 12345678void f(sqList *L) { ElementType *p = L-&gt;Data, temp; for(ElementType *q = L-&gt;Data + L-&gt;length-1; q &gt; p; q--, p++) { temp = *q; *q = *p; *p = temp; }} 参考资料 数据结构（C 语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"},{"name":"线性结构（线性表）","slug":"数据结构与算法大全/线性结构（线性表）","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%89/"}],"tags":[{"name":"线性表","slug":"线性表","permalink":"https://www.mryan2005.top/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"矩阵的秩","slug":"juzhendezhi","date":"2024-05-16T11:29:20.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/50ea32d2.html","permalink":"https://www.mryan2005.top/posts/50ea32d2.html","excerpt":"定义 k 阶子式","text":"定义 k 阶子式 在 m✖️n 的矩阵 A 当中，任取 k 行 k 列（1≤k≤m，1≤k≤n），位于 k2k^2k2 个元素。 m✖️n 矩阵 A 的 k 阶子式共有 Cmk⋅CnkC^k_m·C^k_nCmk​⋅Cnk​个。 设 A 为 m✖️n 矩阵，当 A=Ｏ时，它的任何子式都为零；当 A≠Ｏ时，它至少有一个 r 阶子式不为零。 秩 设Ａ为 m✖️n 矩阵，如果存在Ａ的 r 阶子式不为零，而任何的 r+1 阶子式皆为零，则称数 r 为矩阵 A 的秩，记作 r (A) 或 R (A)。 零矩阵的秩等于零。 除了计算矩阵，还可以通过变换矩阵（使其出现都为 0 的行），直到矩阵不能在变换了。那么有多少行上的元素不为 0，那 r 就等于多少。 性质 若矩阵 A 中有某个 s 阶子式不为 0，则 r (A)≥s； 若 A 中所有的 t 阶子式全为 0，则 r (A)&lt;t； 若 A 为 m✖️n 矩阵，则 0≤r (A)≤min {m,n}； r(A)=r(ATA^TAT)。 当 r (A)=min {m,n} 时，为满阶矩阵，否则为降阶矩阵。 矩阵的秩的计算 当 A 经过一次初等变换变成 B 时，r (A)=r (B)； 何为初等变换？ 交换两行； 一行上的数乘以一个非零常数； 把一行的数乘以一个非零常数加到另一行上。 由此，当矩阵变成行阶梯形矩阵时，矩阵的秩就是矩阵的非零行的行数。","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"矩阵","slug":"线性代数/矩阵","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/"}],"tags":[{"name":"矩阵","slug":"矩阵","permalink":"https://www.mryan2005.top/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"动态分配","slug":"ds-DynamicAllocation","date":"2024-05-16T10:42:21.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/ccb7e96d.html","permalink":"https://www.mryan2005.top/posts/ccb7e96d.html","excerpt":"前情提要 在之前的 C 语言的学习当中，我们提到了 malloc 和 free，这两个函数是用来动态分配内存的。 看好。 动态分配的代码是这样写的。 12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() { int n; scanf(\"%d\", &amp;n); int *a = (int*)malloc(sizeof(int)*n); free(a);} 结构体结构 12345typedef struct { ElemType *data; int length; int listSize;} DA; 我来解释一下，这个结构体声明。 length 是你实际存了多少的东西，listSize 是你目前表的最大长度。 动态分配的使用 其实，无非就是创、增、删、改、读、销。 创建一个动态分配","text":"前情提要 在之前的 C 语言的学习当中，我们提到了 malloc 和 free，这两个函数是用来动态分配内存的。 看好。 动态分配的代码是这样写的。 12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() { int n; scanf(\"%d\", &amp;n); int *a = (int*)malloc(sizeof(int)*n); free(a);} 结构体结构 12345typedef struct { ElemType *data; int length; int listSize;} DA; 我来解释一下，这个结构体声明。 length 是你实际存了多少的东西，listSize 是你目前表的最大长度。 动态分配的使用 其实，无非就是创、增、删、改、读、销。 创建一个动态分配 其实，就是借空间，然后初始化。当然，有的是选择将借空间和初始化这两个操作分开来做。 1234#define INITIALSIZE 100DA da;da.listSize = INITALSIZE;da.length = 0; 初始化动态分配 算了，我还是写出来吧。 1234void initDynamicAllocation(DA *da) { da-&gt;data = (ElemType*)malloc(sizeof(ElemType)*INITIALSIZE); /* initial process */} 添加内容 12345void addContent(DA *da, ElemType content) { ElemType *p = da-&gt;data+length; *p = content; da-&gt;length++;} 参考资料 数据结构（C 语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"},{"name":"线性结构（线性表）","slug":"数据结构与算法大全/线性结构（线性表）","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%89/"}],"tags":[{"name":"动态分配","slug":"动态分配","permalink":"https://www.mryan2005.top/tags/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/"}]},{"title":"简谐运动（入门）","slug":"jianxieyundong","date":"2024-05-14T09:10:32.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/67c22e3.html","permalink":"https://www.mryan2005.top/posts/67c22e3.html","excerpt":"弹簧振子 一端固定，一端连接物体，在平衡位置 O 点反复运动，如下图所示 物理情景：将物块拉到 A 位置上，然后撤掉拉力，物体发生运动。 当物体到达 O 点时，物体加速度为 0，因为弹力为 0； 当物体到达 A 点的时候，速度减为 0。 在这里我们知道，弹力的计算公式是 F=−kxF = -kxF=−kx。 由此，我们可以由加速度公式 a=Fma=\\frac{F}{m}a=mF​ 推出 a=−kxma=-\\frac{kx}{m}a=−mkx​。 由于 ω2=km\\omega^2 = \\frac{k}{m}ω2=mk​，所以，a=−ω2xa = -\\omega^2xa=−ω2x。 而微分方程就是在这基础之上将 aaa 变成 d2xdt2\\frac{d^2x}{dt^2}dt2d2x​。 这里我们要引出一个公式，就是运动方程：x=Acos⁡(wt+ϕ)x = A\\cos(wt+\\phi)x=Acos(wt+ϕ) 然后，我们结合物理学上册的运动描述 v=dxdtv = \\frac{dx}{dt}v=dtdx​，a=dvdta = \\frac{dv}{dt}a=dtdv​，我们可以知道，v=−ωAsin⁡(wt+ϕ)v = - \\omega A\\sin(wt+\\phi)v=−ωAsin(wt+ϕ)，a=ω2Acos⁡(wt+ϕ)a = \\omega^2A\\cos(wt+\\phi)a=ω2Acos(wt+ϕ)","text":"弹簧振子 一端固定，一端连接物体，在平衡位置 O 点反复运动，如下图所示 物理情景：将物块拉到 A 位置上，然后撤掉拉力，物体发生运动。 当物体到达 O 点时，物体加速度为 0，因为弹力为 0； 当物体到达 A 点的时候，速度减为 0。 在这里我们知道，弹力的计算公式是 F=−kxF = -kxF=−kx。 由此，我们可以由加速度公式 a=Fma=\\frac{F}{m}a=mF​ 推出 a=−kxma=-\\frac{kx}{m}a=−mkx​。 由于 ω2=km\\omega^2 = \\frac{k}{m}ω2=mk​，所以，a=−ω2xa = -\\omega^2xa=−ω2x。 而微分方程就是在这基础之上将 aaa 变成 d2xdt2\\frac{d^2x}{dt^2}dt2d2x​。 这里我们要引出一个公式，就是运动方程：x=Acos⁡(wt+ϕ)x = A\\cos(wt+\\phi)x=Acos(wt+ϕ) 然后，我们结合物理学上册的运动描述 v=dxdtv = \\frac{dx}{dt}v=dtdx​，a=dvdta = \\frac{dv}{dt}a=dtdv​，我们可以知道，v=−ωAsin⁡(wt+ϕ)v = - \\omega A\\sin(wt+\\phi)v=−ωAsin(wt+ϕ)，a=ω2Acos⁡(wt+ϕ)a = \\omega^2A\\cos(wt+\\phi)a=ω2Acos(wt+ϕ)","categories":[{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"简谐运动","slug":"物理/简谐运动","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8/"}],"tags":[]},{"title":"线性表入门","slug":"ds-linearList-1","date":"2024-05-12T15:00:51.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/371e8e7e.html","permalink":"https://www.mryan2005.top/posts/371e8e7e.html","excerpt":"定义 线性表（linear list）有以下三个规则： 存在唯一的一个 “第一个” 数据元素 存在唯一的一个 “最后一个” 数据元素 除 “第一个” 和 “最后一个” 元素均只有一个直接前驱（immediate predecessor）和一个直接后继（immediate successor）。 一些参数 线性表长度为 n，也可以直接用 xxLen 表示 当 n=0 时，就是空表 a 的下表 i 表示的是 a(i) 在线性表的位序 一些要说的东西 对于线性表存在两种输入的情况： 不修改内容，只是把内容传入，如 List L 譬如，getLength(List L) 可修改内容，也可把内容传入，就传地址（指针），如 List *L 譬如，initList(List *L) 但是，在此后要访问这指针的内容要用到 L-&gt; 但是，我们要注意的是结构体。 举个例子 这是一个动态分配","text":"定义 线性表（linear list）有以下三个规则： 存在唯一的一个 “第一个” 数据元素 存在唯一的一个 “最后一个” 数据元素 除 “第一个” 和 “最后一个” 元素均只有一个直接前驱（immediate predecessor）和一个直接后继（immediate successor）。 一些参数 线性表长度为 n，也可以直接用 xxLen 表示 当 n=0 时，就是空表 a 的下表 i 表示的是 a(i) 在线性表的位序 一些要说的东西 对于线性表存在两种输入的情况： 不修改内容，只是把内容传入，如 List L 譬如，getLength(List L) 可修改内容，也可把内容传入，就传地址（指针），如 List *L 譬如，initList(List *L) 但是，在此后要访问这指针的内容要用到 L-&gt; 但是，我们要注意的是结构体。 举个例子 这是一个动态分配 12345typedef struct { ElemType *data; int length; int listSize;} DA; 注意，如果我们要修改结构体变量的内容（即 data、length、listSize），那就直接传地址，如果我们只是读取，那就传变量即可。 譬如，我们的读取函数 123void readDA(DA da) { for(int i = 0; i &lt; da.length; i++) printf(\"%d\", da.data[i]);} 这就是直接传变量本身。 如果们要对该变量本身进行一系列的修改的时候，下面的增加函数代码 12345void addContent(DA *da, ElemType content) { ElemType *p = da-&gt;data+da-&gt;length; *p = content; da-&gt;length++;} 这就是直接传地址的。 参考资料 数据结构（C 语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"},{"name":"线性结构（线性表）","slug":"数据结构与算法大全/线性结构（线性表）","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%89/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"},{"name":"线性表","slug":"线性表","permalink":"https://www.mryan2005.top/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"算法的基础知识","slug":"ds-algorithm","date":"2024-05-12T10:51:11.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/5e7b20a2.html","permalink":"https://www.mryan2005.top/posts/5e7b20a2.html","excerpt":"算法的五大特性 确定性 有穷性 可行性 输入和输出（可以没有输入，但是得要有输出）","text":"算法的五大特性 确定性 有穷性 可行性 输入和输出（可以没有输入，但是得要有输出） 辨析 程序是不是算法？ 答案是 False，因为程序可以没有输入。 算法的要求 正确性（correctness） 可读性（readability） 健壮性（robustness） 效率与低储存量需求 算法的书写 我们要把它写成一个函数。 声明行由返回值类型（int、char、double、float、void、long int）、函数名称和形式参数声明区构成 123456returnValueType functionName(type1 value1;type2 value2) { command 1; command 2; …… command n;} 如果没有声明行，那一定要原型声明，如果不进行原型声明，就有可能造成 C 语言去猜测变量。 如果输入参数与定义的不匹配，那么会发生变量类型转换。 当然如果你把要声明的函数放到 main 函数的前面或者是放到头文件当中就不会需要声明行了。 总之，要知道，我们要用到函数来表示一个算法。譬如，我们要从顺序表（从零号位开始存数据，里面的数值都大于等于 0）中返回指定位置的值： 1234567891011/*#define maxSize 100 typedef struct { elementType data[maxSize]; int length;};*/elementType initAlist(seqList *L, int i) { if(i &gt; L-&gt;length) return -1; return L-&gt;data[i-1];} 至于顺序表是什么，为什么要特别声明是从 0 号位开始，我们以后再说。 不过，在这里形式参数声明区代表的是要输入的值的区域，函数名称得表达出算法的用途，实在不行可以随意。 算法的衡量标准 即时间复杂度（time complexity）和空间复杂度（space complexity）。 时间复杂度（time complexity） 又分为事前估计和事后估计 事前估计 语句频度 顺序结构、分支结构、循环结构 —— 运行次数会有变化，取最大的运行次数。 渐进时间复杂度（asymptotic time complexity） T (n) = O (f (n))，渐进时间复杂度。 主要是要找到关键操作（递归和循环），就是嵌套最深的语句，可以是判断、也可以是普通语句。 当存在最好和最坏情况后，用平均复杂度。 例题 1 多重循环 一重循环 事后统计 利用计算机的计时工具，用一组或多组数据去测。缺点是要运行程序，还会依赖于硬件、软件等因素。 空间复杂度（space complexity） 算法本身会占用：输入、输出、指令、常数、变量等。 看看弄出了多少空间被占用。 注意：如果是递归的算法，那就是看层数，不是看节点数，因为递归算法是单线程的弄完一个以后，就会删除掉。 参考资料 详解时间复杂度计算公式 (附例题细致讲解过程) 数据结构（C 语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"},{"name":"入门","slug":"数据结构与算法大全/入门","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"},{"name":"算法","slug":"算法","permalink":"https://www.mryan2005.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"随机事件的概率","slug":"suijishijiandepinglv","date":"2024-05-11T23:59:41.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/98650707.html","permalink":"https://www.mryan2005.top/posts/98650707.html","excerpt":"随机事件的频率 在相同条件下重复进行的 n 次随机试验中，事件 A 发生的次数记为 rn(A)r_n(A)rn​(A)，称 rn(A)r_n(A)rn​(A) 为事件 A 发生的频数，称 fn(A)=rn(A)nf_n(A)=\\frac{r_n(A)}{n}fn​(A)=nrn​(A)​为事件 A 发生的频率。 性质 非负性：0≤fn(A)≤10\\leq f_n(A)\\leq 10≤fn​(A)≤1 规范性：fn(S)=1f_n(S)=1fn​(S)=1 有限可加性：设 A1,A2,……，AnA_1, A_2, ……，A_nA1​,A2​,……，An​是两两互不相容事件，fn(A1∪A2∪⋯∪An)=fn(A1)+fn(A2)+⋯+f(An)f_n(A_1∪A_2∪⋯∪A_n) =f_n(A_1)+f_n(A_2)+⋯+f(A_n)fn​(A1​∪A2​∪⋯∪An​)=fn​(A1​)+fn​(A2​)+⋯+f(An​) 随机事件的概率 相同条件下重复进行 n 次试验，若事件 A 发生的频率 fn(A)f_n(A)fn​(A) 随着试验次数 n 的增大而稳定地在某个常数 P(0≤P≤1)P(0\\leq P\\leq1)P(0≤P≤1) 附近摆动，则称 P 为事件 A 的概率，记为 P(A)P(A)P(A)。 投掷硬币的试验中，正面朝上的概率为 0.50.50.5。","text":"随机事件的频率 在相同条件下重复进行的 n 次随机试验中，事件 A 发生的次数记为 rn(A)r_n(A)rn​(A)，称 rn(A)r_n(A)rn​(A) 为事件 A 发生的频数，称 fn(A)=rn(A)nf_n(A)=\\frac{r_n(A)}{n}fn​(A)=nrn​(A)​为事件 A 发生的频率。 性质 非负性：0≤fn(A)≤10\\leq f_n(A)\\leq 10≤fn​(A)≤1 规范性：fn(S)=1f_n(S)=1fn​(S)=1 有限可加性：设 A1,A2,……，AnA_1, A_2, ……，A_nA1​,A2​,……，An​是两两互不相容事件，fn(A1∪A2∪⋯∪An)=fn(A1)+fn(A2)+⋯+f(An)f_n(A_1∪A_2∪⋯∪A_n) =f_n(A_1)+f_n(A_2)+⋯+f(A_n)fn​(A1​∪A2​∪⋯∪An​)=fn​(A1​)+fn​(A2​)+⋯+f(An​) 随机事件的概率 相同条件下重复进行 n 次试验，若事件 A 发生的频率 fn(A)f_n(A)fn​(A) 随着试验次数 n 的增大而稳定地在某个常数 P(0≤P≤1)P(0\\leq P\\leq1)P(0≤P≤1) 附近摆动，则称 P 为事件 A 的概率，记为 P(A)P(A)P(A)。 投掷硬币的试验中，正面朝上的概率为 0.50.50.5。","categories":[{"name":"数学","slug":"数学","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/"},{"name":"概率论与数理统计","slug":"数学/概率论与数理统计","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"数据的基本概念","slug":"ds-data","date":"2024-05-11T23:02:32.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/10aa7cbc.html","permalink":"https://www.mryan2005.top/posts/10aa7cbc.html","excerpt":"数据（data） 能输入到计算机当中的并能被处理的符号的总称。 数据元素（data item） 数据的基本单位，通常是以一个整体去考虑，有若干个数据项组成，又名记录。 在计算机当中，最小的储存单位是位（bit），就是二进制数的一位。将若干个位组合起来连成一个位串表示一个数据元素，通常这个位串为一个元素（element）或结点（node），有时可以看成是数据元素在计算机中的映像。 当数据元素组成各个数据项时，位串应于各个数据项的子串称为数据域（data field） 数据对象（data object） 性质相同的数据元素的集合，是数据的子集。 数据结构（data structure） 存在一种或一种以上的特殊关系的数据元素的集合 ——Data_Structure = (D,S) D 是数据元素的有限集，S 是 D 上关系的有限集 数据结构通常分为 4 种基本结构： 集合 线性 树 图","text":"数据（data） 能输入到计算机当中的并能被处理的符号的总称。 数据元素（data item） 数据的基本单位，通常是以一个整体去考虑，有若干个数据项组成，又名记录。 在计算机当中，最小的储存单位是位（bit），就是二进制数的一位。将若干个位组合起来连成一个位串表示一个数据元素，通常这个位串为一个元素（element）或结点（node），有时可以看成是数据元素在计算机中的映像。 当数据元素组成各个数据项时，位串应于各个数据项的子串称为数据域（data field） 数据对象（data object） 性质相同的数据元素的集合，是数据的子集。 数据结构（data structure） 存在一种或一种以上的特殊关系的数据元素的集合 ——Data_Structure = (D,S) D 是数据元素的有限集，S 是 D 上关系的有限集 数据结构通常分为 4 种基本结构： 集合 线性 树 图 数据结构在计算机的表示成为数据的物理结构（physical structure），又称为储存结构（storage structure），同时，这也包括了数据元素的表示和关系的表示。 数据项（data element） 数据的最小单位 数据类型（data type） 用于刻画操作对象的特性：譬如，整型数据可以进行加减乘除，字符型的只能进行加减 两大分类： 原子类型，譬如：C 语言中的整型、浮点型、字符型、枚举型 结构类型：若干个数据类型组成（可以是结构的、也可以是非结构的） 抽象数据类型 [ADT]（abstract data type） 分为两种类型： 原子类型 结构类型 固定聚合类型，“值” 确定的 可变聚合类型，“值” 的成分不确定 定义上分为三个部分：数据对象（data object）、数据关系（data relation）、基本操作。 数据的关系描述的是数据元素之间的逻辑关系，由此被称为逻辑关系（logical structure）。 数据关系在计算机的储存方法有两种： 顺序映像 非顺序映像 同时，也有两种储存结构： 顺序储存结构（sequential storage structure） 链式储存结构（linked storage structure） 参考资料 数据结构（C 语言版）| 作者：严蔚敏女士","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"},{"name":"入门","slug":"数据结构与算法大全/入门","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"作者有话说","slug":"ds-author-went-to-say","date":"2024-05-11T22:58:51.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/506fb8af.html","permalink":"https://www.mryan2005.top/posts/506fb8af.html","excerpt":"我依稀记得，小时候的我，便与计算机结下了不解之缘。那时的我，对计算机充满了好奇，总是想要探索这个神奇的小盒子里的奥秘。每次坐在电脑前，我都会瞪大眼睛，仔细观察屏幕上的每一个图标，尝试着去理解它们的功能和用途。 随着时间的推移，我逐渐对计算机产生了热爱之情。我开始沉迷于计算机的命令行，那些看似复杂的指令和代码，在我眼中却充满了魅力。我喜欢通过命令行来控制计算机，完成各种任务，那种掌控感让我兴奋不已。我开始研究各种计算机知识，从硬件到软件，从操作系统到编程语言，我都想要了解得更多。 在小学五年级的时候，我第一次接触到了 C 语言。那时的我，满怀激情地投入到学习中，想要掌握这门强大的编程语言。然而，现实却给我泼了一盆冷水。我发现，我所使用的书籍中充满了错误，这让我感到十分沮丧。最终，我无奈地选择了放弃，转而寻找其他更适合我的编程语言。 初中的时候，我接触到了 Python。与 C 语言相比，Python 的语法更加简洁易懂，让我越用越得心应手。我开始用 Python 编写各种小程序，解决实际问题。我喜欢 Python 的灵活性和强大性，它让我感受到了编程的乐趣。 在填报高考志愿时，我坚决地选择了计算机专业，不顾家人的阻拦。他们总是以我那高考成绩只够上二本末的堂哥为例子，试图说服我放弃这个选择。然而，我深知自己的兴趣和优势所在，我坚信自己能够在计算机专业中取得好成绩。最终，我成功地进入了大学，开始了我的计算机学习之旅。 在上海的校园里，我遇到了一些同样是学计算机的同学。他们中有些人总是喜欢在我面前炫耀自己的成绩和成就，搞些所谓的 “凡尔赛”。然而，我对此却甚为厌恶。我深知，真正的进步和成就不是靠炫耀得来的，而是需要脚踏实地地学习和实践。因此，我选择了超越他们，用自己的努力和成果来证明自己的实力。我坚信，只要我坚持不懈地努力下去，我一定能够在计算机领域取得属于自己的辉煌成就。 在未来的日子里，我将会继续深耕计算机领域，不断提升自己的技能和知识。无论是面对复杂的算法问题，还是应对日新月异的科技变革，我都会保持一颗求知的心，勇于挑战自我，不断超越极限。 或许，我会遇到更多的困难和挑战，但我相信，只要我坚定信念，勇往直前，就一定能够克服一切难关，实现自己的梦想。我期待着在计算机的世界里，书写属于自己的精彩篇章，用智慧和汗水创造出更多的可能。 回首过去，我为自己的选择和坚持感到自豪。展望未来，我充满了信心和期待。我相信，在不久的将来，我将成为一名优秀的计算机专业人才，为社会的进步和发展贡献自己的力量。","text":"我依稀记得，小时候的我，便与计算机结下了不解之缘。那时的我，对计算机充满了好奇，总是想要探索这个神奇的小盒子里的奥秘。每次坐在电脑前，我都会瞪大眼睛，仔细观察屏幕上的每一个图标，尝试着去理解它们的功能和用途。 随着时间的推移，我逐渐对计算机产生了热爱之情。我开始沉迷于计算机的命令行，那些看似复杂的指令和代码，在我眼中却充满了魅力。我喜欢通过命令行来控制计算机，完成各种任务，那种掌控感让我兴奋不已。我开始研究各种计算机知识，从硬件到软件，从操作系统到编程语言，我都想要了解得更多。 在小学五年级的时候，我第一次接触到了 C 语言。那时的我，满怀激情地投入到学习中，想要掌握这门强大的编程语言。然而，现实却给我泼了一盆冷水。我发现，我所使用的书籍中充满了错误，这让我感到十分沮丧。最终，我无奈地选择了放弃，转而寻找其他更适合我的编程语言。 初中的时候，我接触到了 Python。与 C 语言相比，Python 的语法更加简洁易懂，让我越用越得心应手。我开始用 Python 编写各种小程序，解决实际问题。我喜欢 Python 的灵活性和强大性，它让我感受到了编程的乐趣。 在填报高考志愿时，我坚决地选择了计算机专业，不顾家人的阻拦。他们总是以我那高考成绩只够上二本末的堂哥为例子，试图说服我放弃这个选择。然而，我深知自己的兴趣和优势所在，我坚信自己能够在计算机专业中取得好成绩。最终，我成功地进入了大学，开始了我的计算机学习之旅。 在上海的校园里，我遇到了一些同样是学计算机的同学。他们中有些人总是喜欢在我面前炫耀自己的成绩和成就，搞些所谓的 “凡尔赛”。然而，我对此却甚为厌恶。我深知，真正的进步和成就不是靠炫耀得来的，而是需要脚踏实地地学习和实践。因此，我选择了超越他们，用自己的努力和成果来证明自己的实力。我坚信，只要我坚持不懈地努力下去，我一定能够在计算机领域取得属于自己的辉煌成就。 在未来的日子里，我将会继续深耕计算机领域，不断提升自己的技能和知识。无论是面对复杂的算法问题，还是应对日新月异的科技变革，我都会保持一颗求知的心，勇于挑战自我，不断超越极限。 或许，我会遇到更多的困难和挑战，但我相信，只要我坚定信念，勇往直前，就一定能够克服一切难关，实现自己的梦想。我期待着在计算机的世界里，书写属于自己的精彩篇章，用智慧和汗水创造出更多的可能。 回首过去，我为自己的选择和坚持感到自豪。展望未来，我充满了信心和期待。我相信，在不久的将来，我将成为一名优秀的计算机专业人才，为社会的进步和发展贡献自己的力量。","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"序言","slug":"dsxuyan","date":"2024-05-11T21:34:37.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/3491a993.html","permalink":"https://www.mryan2005.top/posts/3491a993.html","excerpt":"在浩瀚的计算机科学领域中，数据结构与算法无疑是其中最璀璨夺目的明珠。然而，想要真正掌握这门学科，却并非一撮而就的易事。它需要我们有足够的耐心，去一步步探寻每一个细节；它需要我们有足够的毅力，去克服每一个难关。因此，学习数据结构与算法，更像是一场循序渐进的修行，需要我们在实践中不断积累、反思与提升。 本书《数据结构与算法大全》正是基于这样的理念而诞生。它不仅仅是一本简单的教程，更是一部集大成之作。在编写过程中，我们深入研究了各种数据结构与算法的原理、特性及应用场景，力求将最精华、最实用的内容呈现给读者。同时，我们也参考了大量的专业书籍、学术论文以及实际项目经验，以期为读者提供一个全面、深入的学习平台。 在书中，你将看到各种经典的数据结构，如数组、链表、栈、队列、树和图等，以及与之相关的算法实现和优化方法。我们将从基础概念讲起，逐步深入到高级应用和算法设计技巧，让你能够逐步建立起自己的知识体系和技能体系。 此外，本书还注重理论与实践的结合。我们不仅在理论层面详细讲解了数据结构与算法的基本原理和特性，还通过大量的示例和案例，让读者能够更好地理解其在实际问题中的应用。相信通过本书的学习，你不仅能够掌握数据结构与算法的核心知识，还能够将其应用于实际项目中，提升自己的编程能力和问题解决能力。 最后，我要感谢所有为这本书付出努力的人，也要感谢每一位选择阅读这本书的读者。希望它能够成为你学习数据结构与算法的良师益友，陪伴你走过一段充满挑战与收获的学习旅程。愿你在这个领域中不断前行，创造出更加辉煌的未来。","text":"在浩瀚的计算机科学领域中，数据结构与算法无疑是其中最璀璨夺目的明珠。然而，想要真正掌握这门学科，却并非一撮而就的易事。它需要我们有足够的耐心，去一步步探寻每一个细节；它需要我们有足够的毅力，去克服每一个难关。因此，学习数据结构与算法，更像是一场循序渐进的修行，需要我们在实践中不断积累、反思与提升。 本书《数据结构与算法大全》正是基于这样的理念而诞生。它不仅仅是一本简单的教程，更是一部集大成之作。在编写过程中，我们深入研究了各种数据结构与算法的原理、特性及应用场景，力求将最精华、最实用的内容呈现给读者。同时，我们也参考了大量的专业书籍、学术论文以及实际项目经验，以期为读者提供一个全面、深入的学习平台。 在书中，你将看到各种经典的数据结构，如数组、链表、栈、队列、树和图等，以及与之相关的算法实现和优化方法。我们将从基础概念讲起，逐步深入到高级应用和算法设计技巧，让你能够逐步建立起自己的知识体系和技能体系。 此外，本书还注重理论与实践的结合。我们不仅在理论层面详细讲解了数据结构与算法的基本原理和特性，还通过大量的示例和案例，让读者能够更好地理解其在实际问题中的应用。相信通过本书的学习，你不仅能够掌握数据结构与算法的核心知识，还能够将其应用于实际项目中，提升自己的编程能力和问题解决能力。 最后，我要感谢所有为这本书付出努力的人，也要感谢每一位选择阅读这本书的读者。希望它能够成为你学习数据结构与算法的良师益友，陪伴你走过一段充满挑战与收获的学习旅程。愿你在这个领域中不断前行，创造出更加辉煌的未来。","categories":[{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"随机事件与概率","slug":"suijishijianyugailv","date":"2024-05-11T21:10:06.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/becb01a7.html","permalink":"https://www.mryan2005.top/posts/becb01a7.html","excerpt":"确定性现象和不确定性现象 确定性现象 如果在一相同条件下的试验中只会有一种结果出现，这种现象称为确定性现象 不确定性现象 如果在一相同条件下的试验中可能出现多种结果，这种现象称为不确定性现象，也称为随机现象。 例子 抛硬币 掷骰子 抽奖 随机试验 特征","text":"确定性现象和不确定性现象 确定性现象 如果在一相同条件下的试验中只会有一种结果出现，这种现象称为确定性现象 不确定性现象 如果在一相同条件下的试验中可能出现多种结果，这种现象称为不确定性现象，也称为随机现象。 例子 抛硬币 掷骰子 抽奖 随机试验 特征 可重复 不确定 可观察 样本空间 随机试验 E 的所有可能结果组成的集合称为 E 的样本空间，记为 S 或 Ω。样本空间的元素称为样本点，用 ω 表示。 分类 离散型的样本空间，以散乱的点表示 连续型的样本空间，以线段表示 随机事件 样本空间 S 的子集称为随机事件，简称事件。 通常以大写字母 A、B、C 等表示事件。 只有 A 中的样本点出现时，称事件 A 发生，否则称事件 A 不发生。B、C 等事件类似。 例子 做如下随机试验：从整数 1~9 中随机抽取一个数，则样本空间 S={1,2,3,4,5,6,7,8,9}S = \\{1,2,3,4,5,6,7,8,9\\}S={1,2,3,4,5,6,7,8,9} 设事件 A 表示抽到的数不小于 5，即 A={5,6,7,8,9}A = \\{5,6,7,8,9\\}A={5,6,7,8,9}。 设事件 B 表示抽到的是偶数，即 B={2,4,6,8}B = \\{2,4,6,8\\}B={2,4,6,8}。 A 同学随机抽取的数是 2，则我们称事件 A 没有发生，事件 B 发生。 B 同学随机抽取的数是 6，则我们称事件 A 和 B 都发生。 C 同学随机抽取的数是 1，则我们称事件 A 和 B 都没有发生。 D 同学随机抽取的数是 9，则我们称事件 A 发生，事件 B 没有发生。 必然事件 一定会发生的事件称为必然事件。也就是这一事件包含所有的样本点。 不可能事件 一定不会发生的事件称为不可能事件。也就是这一事件不包含任何样本点，为空集。 包含关系与相等关系 包含关系 如果属于 A 的样本点必属于 B，则称事件 B 包含事件 A，或称事件 A 被包含于事件 B，记为 A⊂B，或 B⊃A。 事件 A 发生必然导致事件 B 发生。 相等关系 如果 A⊂B 且 B⊂A，则称事件 A 与事件 B 相等，记为 A=B。 事件 A 发生等价于事件 B 发生。 和（并）运算 由属于事件 A 或属于事件 B 的样本点组成的新事件称为事件 A 与事件 B 的和事件，记为 A⋃B 或 A+B。 事件 A 发生或事件 B 发生，即事件 A 与事件 B 中至少有一事件发生。 积（交）运算 由属于事件 A 且属于事件 B 的样本点组成的新事件称为事件 A 与事件 B 的积事件，记为 A⋂B 或 AB。 事件 A 发生且事件 B 发生，即事件 A 与事件 B 同时发生。 差运算 由属于事件 A 且不属于事件 B 的样本点组成的新事件称为事件 A 与事件 B 的差事件，记为 A-B。 事件 A 发生且事件 B 不发生。 对立事件、互不相容（互斥事件）、独立事件 感觉解释这样的东西，只能用人际交往的方式来解释。 对立事件 事件 A 的对立事件记为 A‾\\overline{A}A，即 A‾=S−A\\overline{A} = S - AA=S−A。 一句话，我们两没办法处了，“你出现” 的事件发生，“我出现” 的事件就不发生，反之亦然。（我怎么写也是刚好气头上想出来的，别往心里去） 互不相容事件（互斥事件） 两者之间没有交集，即 A⋂B=∅A⋂B = \\emptysetA⋂B=∅。 这像不像你跟一些人的思想，无论怎么谈，都谈不到一块去。 独立事件 A 事件的发生不影响 B 事件的发生，B 事件的发生不影响 A 事件的发生。 符合 P(AB)=P(A)P(B)P(AB) = P(A)P(B)P(AB)=P(A)P(B) 的事件称为独立事件。 注意：P(A‾B‾)=P(A‾)P(B‾)P(\\overline{A}\\overline{B}) = P(\\overline{A})P(\\overline{B})P(AB)=P(A)P(B) 也成立。 事件的运算律 交换律：A⋃B=B⋃AA⋃B = B⋃AA⋃B=B⋃A，AB=BAAB = BAAB=BA 结合律：(A⋃B)⋃C=A⋃(B⋃C)(A⋃B)⋃C = A⋃(B⋃C)(A⋃B)⋃C=A⋃(B⋃C)，(AB)C=A(BC)(AB)C = A(BC)(AB)C=A(BC) 分配律：A(B⋃C)=AB⋃ACA(B⋃C) = AB⋃ACA(B⋃C)=AB⋃AC，A⋃(BC)=(A⋃B)(A⋃C)A⋃(BC) = (A⋃B)(A⋃C)A⋃(BC)=(A⋃B)(A⋃C) 对偶律：A⋃B‾=A‾⋂B‾\\overline{A⋃B} = \\overline{A}⋂\\overline{B}A⋃B​=A⋂B，AB‾=A‾⋃B‾\\overline{AB} = \\overline{A}⋃\\overline{B}AB=A⋃B","categories":[{"name":"数学","slug":"数学","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/"},{"name":"概率论与数理统计","slug":"数学/概率论与数理统计","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"}]},{"title":"test_all_things","slug":"test-all-things","date":"2024-05-11T20:06:44.000Z","updated":"2024-06-02T02:12:12.200Z","comments":true,"path":"posts/90341f05.html","permalink":"https://www.mryan2005.top/posts/90341f05.html","excerpt":"mathjax test INLINE EQUATIONS y=mx+by = mx + by=mx+b","text":"mathjax test INLINE EQUATIONS y=mx+by = mx + by=mx+b MULTI-LINE EQUATIONS evidencei=∑jWijxj+bievidence_{i}=\\sum_{j}W_{ij}x_{j}+b_{i} evidencei​=j∑​Wij​xj​+bi​ code test 12def test(): print(\"test\") mindmap","categories":[{"name":"test example","slug":"test-example","permalink":"https://www.mryan2005.top/categories/test-example/"}],"tags":[{"name":"test","slug":"test","permalink":"https://www.mryan2005.top/tags/test/"}]}],"categories":[{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/categories/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.mryan2005.top/categories/Markdown/"},{"name":"Latex","slug":"Markdown/Latex","permalink":"https://www.mryan2005.top/categories/Markdown/Latex/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://www.mryan2005.top/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"线性代数","slug":"线性代数","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"矩阵","slug":"线性代数/矩阵","permalink":"https://www.mryan2005.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9F%A9%E9%98%B5/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mryan2005.top/categories/LeetCode/"},{"name":"简单题","slug":"LeetCode/简单题","permalink":"https://www.mryan2005.top/categories/LeetCode/%E7%AE%80%E5%8D%95%E9%A2%98/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://www.mryan2005.top/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"参数估计","slug":"概率论与数理统计/参数估计","permalink":"https://www.mryan2005.top/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"name":"数据结构与算法大全","slug":"数据结构与算法大全","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/"},{"name":"线性结构（线性表）","slug":"数据结构与算法大全/线性结构（线性表）","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%89/"},{"name":"物理","slug":"物理","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/"},{"name":"光学","slug":"物理/光学","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E5%85%89%E5%AD%A6/"},{"name":"剪辑","slug":"剪辑","permalink":"https://www.mryan2005.top/categories/%E5%89%AA%E8%BE%91/"},{"name":"简谐运动","slug":"物理/简谐运动","permalink":"https://www.mryan2005.top/categories/%E7%89%A9%E7%90%86/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8/"},{"name":"入门","slug":"数据结构与算法大全/入门","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%85%A5%E9%97%A8/"},{"name":"数学","slug":"数学","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/"},{"name":"概率论与数理统计","slug":"数学/概率论与数理统计","permalink":"https://www.mryan2005.top/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"test example","slug":"test-example","permalink":"https://www.mryan2005.top/categories/test-example/"}],"tags":[{"name":"更新日志","slug":"更新日志","permalink":"https://www.mryan2005.top/tags/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"},{"name":"Latex","slug":"Latex","permalink":"https://www.mryan2005.top/tags/Latex/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.mryan2005.top/tags/Markdown/"},{"name":"向量","slug":"向量","permalink":"https://www.mryan2005.top/tags/%E5%90%91%E9%87%8F/"},{"name":"矩阵","slug":"矩阵","permalink":"https://www.mryan2005.top/tags/%E7%9F%A9%E9%98%B5/"},{"name":"二叉树的中序遍历","slug":"二叉树的中序遍历","permalink":"https://www.mryan2005.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"栈","slug":"栈","permalink":"https://www.mryan2005.top/tags/%E6%A0%88/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.mryan2005.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.mryan2005.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://www.mryan2005.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://www.mryan2005.top/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"Stack","slug":"Stack","permalink":"https://www.mryan2005.top/tags/Stack/"},{"name":"对数字的处理","slug":"对数字的处理","permalink":"https://www.mryan2005.top/tags/%E5%AF%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%A4%84%E7%90%86/"},{"name":"线性表","slug":"线性表","permalink":"https://www.mryan2005.top/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"动态分配","slug":"动态分配","permalink":"https://www.mryan2005.top/tags/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/"},{"name":"第一版","slug":"第一版","permalink":"https://www.mryan2005.top/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"},{"name":"算法","slug":"算法","permalink":"https://www.mryan2005.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"test","slug":"test","permalink":"https://www.mryan2005.top/tags/test/"}]}