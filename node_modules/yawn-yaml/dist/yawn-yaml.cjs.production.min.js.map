{"version":3,"file":"yawn-yaml.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["'use strict';\n\nimport { compose, serialize } from 'yaml-js';\nimport { load, dump } from 'js-yaml';\nimport {\n  isArray,\n  isString,\n  isObject,\n  isUndefined,\n  isNull,\n  isNumber,\n  isEqual,\n  repeat,\n  each,\n  includes,\n  last,\n} from 'lodash';\n\nconst EOL = '\\n';\n\nconst NULL_TAG = 'tag:yaml.org,2002:null';\nconst STR_TAG = 'tag:yaml.org,2002:str';\nconst INT_TAG = 'tag:yaml.org,2002:int';\nconst FLOAT_TAG = 'tag:yaml.org,2002:float';\nconst MAP_TAG = 'tag:yaml.org,2002:map';\nconst SEQ_TAG = 'tag:yaml.org,2002:seq';\n\nconst SPACE = ' ';\nconst DASH = '-';\n\nexport class YAWNError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = 'YAWNError';\n  }\n}\n\ninterface Node {\n  start_mark: { pointer: number; column: number };\n  end_mark: { pointer: number; column: number };\n  value: any;\n  tag: string;\n}\n\n// export default class YAWN {\nexport default class YAWN {\n  yaml: string;\n  constructor(str: string) {\n    if (!isString(str)) {\n      throw new TypeError('str should be a string');\n    }\n\n    this.yaml = str;\n  }\n\n  get json() {\n    return load(this.yaml);\n  }\n\n  set json(newJson: any) {\n    // if json is not changed do nothing\n    if (isEqual(this.json, newJson)) {\n      return;\n    }\n\n    const ast = compose(this.yaml);\n\n    if (isUndefined(newJson)) {\n      this.yaml = '';\n      return;\n    }\n\n    // -------------------------------------------------------------------------\n    // check if entire json is changed\n    // -------------------------------------------------------------------------\n    let newTag = getTag(newJson);\n\n    if (ast.tag !== newTag) {\n      let newYaml = cleanDump(newJson);\n\n      // replace this.yaml value from start to end mark with newYaml if node is\n      // primitive\n      if (!isObject(newJson)) {\n        this.yaml = replacePrimitive(ast, newYaml, this.yaml, 0);\n\n        // if node is not primitive\n      } else {\n        this.yaml = replaceNode(ast, newYaml, this.yaml, 0);\n      }\n\n      return;\n    }\n\n    // -------------------------------------------------------------------------\n    // NULL_TAG, STR_TAG, INT_TAG, FLOAT_TAG\n    // -------------------------------------------------------------------------\n    if (includes([NULL_TAG, STR_TAG, INT_TAG, FLOAT_TAG], ast.tag)) {\n      this.yaml = replacePrimitive(ast, newJson, this.yaml, 0);\n\n      return;\n    }\n\n    // -------------------------------------------------------------------------\n    // MAP_TAG\n    // -------------------------------------------------------------------------\n    if (ast.tag === MAP_TAG) {\n      let json = this.json;\n\n      this.yaml = updateMap(ast, newJson, json, this.yaml, 0);\n    }\n\n    // -------------------------------------------------------------------------\n    // SEQ_TAG\n    // -------------------------------------------------------------------------\n    if (ast.tag === SEQ_TAG) {\n      this.yaml = updateSeq(ast, newJson, this.yaml, 0);\n    }\n\n    // Trim trailing whitespaces\n    this.yaml = this.yaml\n      .split(EOL)\n      .map(line => line.replace(/[ \\t]+$/, ''))\n      .join(EOL);\n  }\n\n  toString() {\n    return this.yaml;\n  }\n\n  toJSON() {\n    return this.json;\n  }\n\n  getRemark(path: string) {\n    const ast = compose(this.yaml);\n    let pathlist = path.split('.');\n    let node = getNode(ast, pathlist);\n    return node && getNodeRemark(node, this.yaml);\n  }\n\n  setRemark(path: string, remark: string) {\n    const ast = compose(this.yaml);\n    let pathlist = path.split('.');\n    let node = getNode(ast, pathlist);\n    return !!node && !!(this.yaml = setNodeRemark(node, remark, this.yaml));\n  }\n}\n\n/*\n * Determines the AST tag of a JSON object\n *\n */\nfunction getTag(json: any) {\n  let tag = null;\n\n  if (isArray(json)) {\n    tag = SEQ_TAG;\n  } else if (isObject(json)) {\n    tag = MAP_TAG;\n  } else if (isNull(json)) {\n    tag = NULL_TAG;\n  } else if (isNumber(json)) {\n    if (json % 10 === 0) {\n      tag = INT_TAG;\n    } else {\n      tag = FLOAT_TAG;\n    }\n  } else if (isString(json)) {\n    tag = STR_TAG;\n  } else {\n    throw new YAWNError('Unknown type');\n  }\n  return tag;\n}\n\n/*\n * Update a sequence with new JSON\n */\nfunction updateSeq(\n  ast: Node,\n  newJson: any[],\n  yaml: string,\n  offset: number\n): string {\n  let values: any[] = load(serialize(ast)) as any[];\n  let min: number = Math.min(values.length, newJson.length);\n  for (let i: number = 0; i < min; i++) {\n    const newYaml: string = changeArrayElement(\n      ast.value[i],\n      cleanDump(newJson[i]),\n      yaml,\n      offset\n    );\n    offset = offset + newYaml.length - yaml.length;\n    yaml = newYaml;\n  }\n\n  if (values.length > min) {\n    for (let i: number = min; i < values.length; i++) {\n      const newYaml: string = removeArrayElement(ast.value[i], yaml, offset);\n      offset = offset + newYaml.length - yaml.length;\n      yaml = newYaml;\n    }\n  } else if (newJson.length > min) {\n    yaml = insertAfterNode(ast, cleanDump(newJson.slice(min)), yaml, offset);\n  }\n\n  return yaml;\n}\n\n/*\n * update a map structure with new values\n */\nfunction updateMap(\n  ast: Node,\n  newJson: any,\n  json: any,\n  yaml: string,\n  offset: number\n) {\n  // look for changes\n  each(ast.value, pair => {\n    let [keyNode, valNode] = pair;\n\n    // node is deleted\n    if (isUndefined(newJson[keyNode.value])) {\n      // TODO: can we use of the methods below?\n      const newYaml =\n        yaml.substr(0, keyNode.start_mark.pointer + offset) +\n        yaml.substring(getNodeEndMark(valNode).pointer + offset);\n      offset = offset + newYaml.length - yaml.length;\n      yaml = newYaml;\n      return;\n    }\n\n    let value = json[keyNode.value];\n    let newValue = newJson[keyNode.value];\n\n    // primitive value has changed\n    if (newValue !== value && !isArray(valNode.value)) {\n      // replace the value node\n      const newYaml = replacePrimitive(valNode, newValue, yaml, offset);\n      offset = offset + newYaml.length - yaml.length;\n      yaml = newYaml;\n      // remove the key/value from newJson so it's not detected as new pair in\n      // later code\n      delete newJson[keyNode.value];\n    }\n\n    // non primitive value has changed\n    if (!isEqual(newValue, value) && isArray(valNode.value)) {\n      // array value has changed\n      if (isArray(newValue)) {\n        // recurse\n        const newYaml = updateSeq(valNode, newValue, yaml, offset);\n        offset = offset + newYaml.length - yaml.length;\n        yaml = newYaml;\n\n        // map value has changed\n      } else {\n        // recurse\n        const newYaml = updateMap(valNode, newValue, value, yaml, offset);\n        offset = offset + newYaml.length - yaml.length;\n        yaml = newYaml;\n\n        // ast = compose(yaml);\n\n        // remove the key/value from newJson so it's not detected as new pair in\n        // later code\n        delete newJson[keyNode.value];\n      }\n    }\n  });\n\n  // look for new items to add\n  each(newJson, (value, key) => {\n    // item is new\n    if (isUndefined(json[key])) {\n      let newValue = cleanDump({ [key]: value });\n\n      const newYaml = insertAfterNode(ast, newValue, yaml, offset);\n      offset = offset + newYaml.length - yaml.length;\n      yaml = newYaml;\n    }\n  });\n\n  return yaml;\n}\n\n/*\n * Place value in node range in yaml string\n */\nfunction replacePrimitive(\n  node: Node,\n  value: unknown,\n  yaml: string,\n  offset: number\n) {\n  return (\n    yaml.substr(0, node.start_mark.pointer + offset) +\n    String(value) +\n    yaml.substring(node.end_mark.pointer + offset)\n  );\n}\n\n/*\n * Place value in node range in yaml string\n */\nfunction replaceNode(node: Node, value: string, yaml: string, offset: number) {\n  let indentedValue = indent(value, node.start_mark.column);\n  let lineStart = node.start_mark.pointer - node.start_mark.column + offset;\n\n  return (\n    yaml.substr(0, lineStart) +\n    indentedValue +\n    yaml.substring(getNodeEndMark(node).pointer + offset)\n  );\n}\n\n/*\n * Place value after node range in yaml string\n */\nfunction insertAfterNode(\n  node: Node,\n  value: string,\n  yaml: string,\n  offset: number\n) {\n  let indentedValue = indent(value, node.start_mark.column);\n\n  return (\n    yaml.substr(0, getNodeEndMark(node).pointer + offset) +\n    EOL +\n    indentedValue +\n    yaml.substring(getNodeEndMark(node).pointer + offset)\n  );\n}\n\n/*\n * Removes a node from array\n */\nfunction removeArrayElement(node: Node, yaml: string, offset: number) {\n  let index = node.start_mark.pointer - node.start_mark.column - 1 + offset;\n\n  return (\n    yaml.substr(0, index) +\n    yaml.substring(getNodeEndMark(node).pointer + offset)\n  );\n}\n\n/*\n * Changes a node from array\n */\nfunction changeArrayElement(\n  node: Node,\n  value: string,\n  yaml: string,\n  offset: number\n): string {\n  let indentedValue = indent(value, node.start_mark.column);\n\n  // find index of DASH(`-`) character for this array\n  let index = node.start_mark.pointer + offset;\n  while (index > 0 && yaml[index] !== DASH) {\n    index--;\n  }\n\n  return (\n    yaml.substr(0, index + 2) +\n    indentedValue.substr(node.start_mark.column) +\n    yaml.substring(getNodeEndMark(node).pointer + offset)\n  );\n}\n\n/*\n * Gets end mark of an AST\n */\nfunction getNodeEndMark(ast: Node): Node['end_mark'] {\n  if (isArray(ast.value) && ast.value.length) {\n    let lastItem = last(ast.value);\n\n    if (isArray(lastItem) && lastItem.length) {\n      return getNodeEndMark(last(lastItem));\n    }\n\n    return getNodeEndMark(lastItem);\n  }\n\n  return ast.end_mark;\n}\n\n/*\n * Indents a string with number of characters\n */\nfunction indent(str: string, depth: number) {\n  return str\n    .split(EOL)\n    .filter(line => line)\n    .map(line => repeat(SPACE, depth) + line)\n    .join(EOL);\n}\n\n/*\n * Dump a value to YAML sting without the trailing new line\n */\nfunction cleanDump(value: any) {\n  let yaml = dump(value).replace(/\\n$/, '');\n\n  if (EOL !== '\\n') {\n    yaml = yaml.replace(/\\n/g, EOL);\n  }\n\n  return yaml;\n}\n\n/*\n * Gets remark of an AST\n */\nfunction getNodeRemark(ast: Node, yaml: string) {\n  let index = getNodeEndMark(ast).pointer;\n  while (index < yaml.length && yaml[index] !== '#' && yaml[index] !== EOL) {\n    ++index;\n  }\n\n  if (EOL === yaml[index] || index === yaml.length) {\n    return '';\n  } else {\n    while (\n      index < yaml.length &&\n      (yaml[index] === '#' || yaml[index] === ' ')\n    ) {\n      ++index;\n    }\n    let end = index;\n    while (end < yaml.length && yaml[end] !== EOL) {\n      ++end;\n    }\n    return yaml.substring(index, end);\n  }\n}\n\n/*\n * Sets remark of an AST\n */\nfunction setNodeRemark(ast: Node, remark: string, yaml: string) {\n  let index = getNodeEndMark(ast).pointer;\n  while (index < yaml.length && yaml[index] !== '#' && yaml[index] !== EOL) {\n    ++index;\n  }\n\n  if (EOL === yaml[index] || index === yaml.length) {\n    return yaml.substr(0, index) + ' # ' + remark + yaml.substring(index);\n  } else {\n    while (\n      index < yaml.length &&\n      (yaml[index] === '#' || yaml[index] === ' ')\n    ) {\n      ++index;\n    }\n    let end = index;\n    while (end < yaml.length && yaml[end] !== EOL) {\n      ++end;\n    }\n    return yaml.substr(0, index) + remark + yaml.substring(end);\n  }\n}\n\n/*\n * Gets node of an AST which path\n */\nfunction getNode(ast: Node, path: string | any[]): Node | undefined {\n  if (path.length) {\n    if (ast.tag === MAP_TAG) {\n      let value = ast.value;\n      for (let i = 0; i < value.length; ++i) {\n        let [keyNode, valNode] = value[i];\n        if (path[0] === keyNode.value) {\n          return getNode(valNode, path.slice(1));\n        }\n      }\n      return undefined;\n    } else if (ast.tag === SEQ_TAG) {\n      return ast.value[path[0]] && getNode(ast.value[path[0]], path.slice(1));\n    }\n  }\n  return ast;\n}\n"],"names":["MAP_TAG","SEQ_TAG","YAWNError","_Error","message","_this","call","name","_wrapNativeSuper","Error","YAWN","str","isString","TypeError","this","yaml","_proto","prototype","toString","toJSON","json","getRemark","path","node","getNode","compose","split","ast","index","getNodeEndMark","pointer","length","end","substring","getNodeRemark","setRemark","remark","substr","setNodeRemark","key","get","load","set","newJson","isEqual","isUndefined","newTag","tag","isArray","isObject","isNull","isNumber","getTag","indentedValue","includes","replacePrimitive","updateMap","offset","each","value","pair","keyNode","valNode","newYaml","start_mark","newValue","updateSeq","_cleanDump","cleanDump","insertAfterNode","map","line","replace","join","indent","column","values","serialize","min","Math","i","changeArrayElement","removeArrayElement","slice","String","end_mark","lastItem","last","depth","filter","repeat","dump","_value$i"],"mappings":"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"}