import { compose, serialize } from 'yaml-js';
import { load, dump } from 'js-yaml';
import { isEqual, isUndefined, isObject, includes, isArray, isNull, isNumber, isString, each, repeat, last } from 'lodash-es';

function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn === "function";
  }
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}

var EOL = '\n';
var NULL_TAG = 'tag:yaml.org,2002:null';
var STR_TAG = 'tag:yaml.org,2002:str';
var INT_TAG = 'tag:yaml.org,2002:int';
var FLOAT_TAG = 'tag:yaml.org,2002:float';
var MAP_TAG = 'tag:yaml.org,2002:map';
var SEQ_TAG = 'tag:yaml.org,2002:seq';
var SPACE = ' ';
var DASH = '-';
var YAWNError = /*#__PURE__*/function (_Error) {
  function YAWNError(message) {
    var _this;
    _this = _Error.call(this, message) || this;
    _this.message = message;
    _this.name = 'YAWNError';
    return _this;
  }
  _inheritsLoose(YAWNError, _Error);
  return YAWNError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
// export default class YAWN {
var YAWN = /*#__PURE__*/function () {
  function YAWN(str) {
    if (!isString(str)) {
      throw new TypeError('str should be a string');
    }
    this.yaml = str;
  }
  var _proto = YAWN.prototype;
  _proto.toString = function toString() {
    return this.yaml;
  };
  _proto.toJSON = function toJSON() {
    return this.json;
  };
  _proto.getRemark = function getRemark(path) {
    var ast = compose(this.yaml);
    var pathlist = path.split('.');
    var node = getNode(ast, pathlist);
    return node && getNodeRemark(node, this.yaml);
  };
  _proto.setRemark = function setRemark(path, remark) {
    var ast = compose(this.yaml);
    var pathlist = path.split('.');
    var node = getNode(ast, pathlist);
    return !!node && !!(this.yaml = setNodeRemark(node, remark, this.yaml));
  };
  return _createClass(YAWN, [{
    key: "json",
    get: function get() {
      return load(this.yaml);
    },
    set: function set(newJson) {
      // if json is not changed do nothing
      if (isEqual(this.json, newJson)) {
        return;
      }
      var ast = compose(this.yaml);
      if (isUndefined(newJson)) {
        this.yaml = '';
        return;
      }
      // -------------------------------------------------------------------------
      // check if entire json is changed
      // -------------------------------------------------------------------------
      var newTag = getTag(newJson);
      if (ast.tag !== newTag) {
        var newYaml = cleanDump(newJson);
        // replace this.yaml value from start to end mark with newYaml if node is
        // primitive
        if (!isObject(newJson)) {
          this.yaml = replacePrimitive(ast, newYaml, this.yaml, 0);
          // if node is not primitive
        } else {
          this.yaml = replaceNode(ast, newYaml, this.yaml, 0);
        }
        return;
      }
      // -------------------------------------------------------------------------
      // NULL_TAG, STR_TAG, INT_TAG, FLOAT_TAG
      // -------------------------------------------------------------------------
      if (includes([NULL_TAG, STR_TAG, INT_TAG, FLOAT_TAG], ast.tag)) {
        this.yaml = replacePrimitive(ast, newJson, this.yaml, 0);
        return;
      }
      // -------------------------------------------------------------------------
      // MAP_TAG
      // -------------------------------------------------------------------------
      if (ast.tag === MAP_TAG) {
        var json = this.json;
        this.yaml = updateMap(ast, newJson, json, this.yaml, 0);
      }
      // -------------------------------------------------------------------------
      // SEQ_TAG
      // -------------------------------------------------------------------------
      if (ast.tag === SEQ_TAG) {
        this.yaml = updateSeq(ast, newJson, this.yaml, 0);
      }
      // Trim trailing whitespaces
      this.yaml = this.yaml.split(EOL).map(function (line) {
        return line.replace(/[ \t]+$/, '');
      }).join(EOL);
    }
  }]);
}();
function getTag(json) {
  var tag = null;
  if (isArray(json)) {
    tag = SEQ_TAG;
  } else if (isObject(json)) {
    tag = MAP_TAG;
  } else if (isNull(json)) {
    tag = NULL_TAG;
  } else if (isNumber(json)) {
    if (json % 10 === 0) {
      tag = INT_TAG;
    } else {
      tag = FLOAT_TAG;
    }
  } else if (isString(json)) {
    tag = STR_TAG;
  } else {
    throw new YAWNError('Unknown type');
  }
  return tag;
}
/*
 * Update a sequence with new JSON
 */
function updateSeq(ast, newJson, yaml, offset) {
  var values = load(serialize(ast));
  var min = Math.min(values.length, newJson.length);
  for (var i = 0; i < min; i++) {
    var newYaml = changeArrayElement(ast.value[i], cleanDump(newJson[i]), yaml, offset);
    offset = offset + newYaml.length - yaml.length;
    yaml = newYaml;
  }
  if (values.length > min) {
    for (var _i = min; _i < values.length; _i++) {
      var _newYaml = removeArrayElement(ast.value[_i], yaml, offset);
      offset = offset + _newYaml.length - yaml.length;
      yaml = _newYaml;
    }
  } else if (newJson.length > min) {
    yaml = insertAfterNode(ast, cleanDump(newJson.slice(min)), yaml, offset);
  }
  return yaml;
}
/*
 * update a map structure with new values
 */
function updateMap(ast, newJson, json, yaml, offset) {
  // look for changes
  each(ast.value, function (pair) {
    var keyNode = pair[0],
      valNode = pair[1];
    // node is deleted
    if (isUndefined(newJson[keyNode.value])) {
      // TODO: can we use of the methods below?
      var newYaml = yaml.substr(0, keyNode.start_mark.pointer + offset) + yaml.substring(getNodeEndMark(valNode).pointer + offset);
      offset = offset + newYaml.length - yaml.length;
      yaml = newYaml;
      return;
    }
    var value = json[keyNode.value];
    var newValue = newJson[keyNode.value];
    // primitive value has changed
    if (newValue !== value && !isArray(valNode.value)) {
      // replace the value node
      var _newYaml2 = replacePrimitive(valNode, newValue, yaml, offset);
      offset = offset + _newYaml2.length - yaml.length;
      yaml = _newYaml2;
      // remove the key/value from newJson so it's not detected as new pair in
      // later code
      delete newJson[keyNode.value];
    }
    // non primitive value has changed
    if (!isEqual(newValue, value) && isArray(valNode.value)) {
      // array value has changed
      if (isArray(newValue)) {
        // recurse
        var _newYaml3 = updateSeq(valNode, newValue, yaml, offset);
        offset = offset + _newYaml3.length - yaml.length;
        yaml = _newYaml3;
        // map value has changed
      } else {
        // recurse
        var _newYaml4 = updateMap(valNode, newValue, value, yaml, offset);
        offset = offset + _newYaml4.length - yaml.length;
        yaml = _newYaml4;
        // ast = compose(yaml);
        // remove the key/value from newJson so it's not detected as new pair in
        // later code
        delete newJson[keyNode.value];
      }
    }
  });
  // look for new items to add
  each(newJson, function (value, key) {
    // item is new
    if (isUndefined(json[key])) {
      var _cleanDump;
      var newValue = cleanDump((_cleanDump = {}, _cleanDump[key] = value, _cleanDump));
      var newYaml = insertAfterNode(ast, newValue, yaml, offset);
      offset = offset + newYaml.length - yaml.length;
      yaml = newYaml;
    }
  });
  return yaml;
}
/*
 * Place value in node range in yaml string
 */
function replacePrimitive(node, value, yaml, offset) {
  return yaml.substr(0, node.start_mark.pointer + offset) + String(value) + yaml.substring(node.end_mark.pointer + offset);
}
/*
 * Place value in node range in yaml string
 */
function replaceNode(node, value, yaml, offset) {
  var indentedValue = indent(value, node.start_mark.column);
  var lineStart = node.start_mark.pointer - node.start_mark.column + offset;
  return yaml.substr(0, lineStart) + indentedValue + yaml.substring(getNodeEndMark(node).pointer + offset);
}
/*
 * Place value after node range in yaml string
 */
function insertAfterNode(node, value, yaml, offset) {
  var indentedValue = indent(value, node.start_mark.column);
  return yaml.substr(0, getNodeEndMark(node).pointer + offset) + EOL + indentedValue + yaml.substring(getNodeEndMark(node).pointer + offset);
}
/*
 * Removes a node from array
 */
function removeArrayElement(node, yaml, offset) {
  var index = node.start_mark.pointer - node.start_mark.column - 1 + offset;
  return yaml.substr(0, index) + yaml.substring(getNodeEndMark(node).pointer + offset);
}
/*
 * Changes a node from array
 */
function changeArrayElement(node, value, yaml, offset) {
  var indentedValue = indent(value, node.start_mark.column);
  // find index of DASH(`-`) character for this array
  var index = node.start_mark.pointer + offset;
  while (index > 0 && yaml[index] !== DASH) {
    index--;
  }
  return yaml.substr(0, index + 2) + indentedValue.substr(node.start_mark.column) + yaml.substring(getNodeEndMark(node).pointer + offset);
}
/*
 * Gets end mark of an AST
 */
function getNodeEndMark(ast) {
  if (isArray(ast.value) && ast.value.length) {
    var lastItem = last(ast.value);
    if (isArray(lastItem) && lastItem.length) {
      return getNodeEndMark(last(lastItem));
    }
    return getNodeEndMark(lastItem);
  }
  return ast.end_mark;
}
/*
 * Indents a string with number of characters
 */
function indent(str, depth) {
  return str.split(EOL).filter(function (line) {
    return line;
  }).map(function (line) {
    return repeat(SPACE, depth) + line;
  }).join(EOL);
}
/*
 * Dump a value to YAML sting without the trailing new line
 */
function cleanDump(value) {
  var yaml = dump(value).replace(/\n$/, '');
  return yaml;
}
/*
 * Gets remark of an AST
 */
function getNodeRemark(ast, yaml) {
  var index = getNodeEndMark(ast).pointer;
  while (index < yaml.length && yaml[index] !== '#' && yaml[index] !== EOL) {
    ++index;
  }
  if (EOL === yaml[index] || index === yaml.length) {
    return '';
  } else {
    while (index < yaml.length && (yaml[index] === '#' || yaml[index] === ' ')) {
      ++index;
    }
    var end = index;
    while (end < yaml.length && yaml[end] !== EOL) {
      ++end;
    }
    return yaml.substring(index, end);
  }
}
/*
 * Sets remark of an AST
 */
function setNodeRemark(ast, remark, yaml) {
  var index = getNodeEndMark(ast).pointer;
  while (index < yaml.length && yaml[index] !== '#' && yaml[index] !== EOL) {
    ++index;
  }
  if (EOL === yaml[index] || index === yaml.length) {
    return yaml.substr(0, index) + ' # ' + remark + yaml.substring(index);
  } else {
    while (index < yaml.length && (yaml[index] === '#' || yaml[index] === ' ')) {
      ++index;
    }
    var end = index;
    while (end < yaml.length && yaml[end] !== EOL) {
      ++end;
    }
    return yaml.substr(0, index) + remark + yaml.substring(end);
  }
}
/*
 * Gets node of an AST which path
 */
function getNode(ast, path) {
  if (path.length) {
    if (ast.tag === MAP_TAG) {
      var value = ast.value;
      for (var i = 0; i < value.length; ++i) {
        var _value$i = value[i],
          keyNode = _value$i[0],
          valNode = _value$i[1];
        if (path[0] === keyNode.value) {
          return getNode(valNode, path.slice(1));
        }
      }
      return undefined;
    } else if (ast.tag === SEQ_TAG) {
      return ast.value[path[0]] && getNode(ast.value[path[0]], path.slice(1));
    }
  }
  return ast;
}

export default YAWN;
export { YAWNError };
//# sourceMappingURL=yawn-yaml.esm.js.map
